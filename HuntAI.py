import streamlit as st
import os
import sys
from dotenv import load_dotenv
import google.generativeai as genai
from PIL import Image
from io import BytesIO
import requests
import time
import json
from urllib.parse import urlparse
import streamlit.components.v1 as components
import yaml
import subprocess
import uuid
import re
import pandas as pd
import logging
import shlex
import zipfile 
import tempfile 
import database
from streamlit_option_menu import option_menu

# --- IN√çCIO DA CORRE√á√ÉO: INICIALIZA√á√ÉO DO BANCO DE DADOS ---
# Chame a fun√ß√£o de inicializa√ß√£o aqui, no escopo global do script.
# Isso garante que as tabelas ser√£o criadas ANTES de qualquer outra fun√ß√£o ser chamada.
try:
    database.init_db()
    # Adicionamos uma flag no session_state para sabermos que o DB est√° pronto.
    st.session_state.db_initialized = True 
except Exception as e:
    st.error(f"FALHA CR√çTICA AO INICIALIZAR O BANCO DE DADOS: {e}")
    st.warning("O aplicativo pode n√£o funcionar corretamente. Verifique as permiss√µes da pasta.")
    st.session_state.db_initialized = False
# --- FIM DA CORRE√á√ÉO ---

# --- Configura√ß√µes do LLM (Temperatura Reduzida para Consist√™ncia) ---
LLM_TEMPERATURE = 0.1

st.set_page_config(
    layout="wide",
    page_title="HuntIA - Pentest Suite",  # NOVO: Altera o t√≠tulo da aba do navegador
    page_icon="üïµÔ∏è"  # NOVO: Altera o √≠cone da aba do navegador. Pode ser um emoji ou o caminho para um arquivo de imagem (ex: "images/favicon.png")
)


# --- Configura√ß√£o do Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', filename='huntia.log')
# logging.getLogger().addHandler(logging.StreamHandler()) # Para ver no console durante o desenvolvimento
# --- Fim Configura√ß√£o do Logging ---

# --- Configura√ß√£o do LLM e APIs ---
load_dotenv()
API_KEY = os.getenv("GOOGLE_API_KEY")

if not API_KEY:
    st.error("ERRO: A vari√°vel de ambiente 'GOOGLE_API_KEY' n√£o est√° configurada.")
    st.info("Por favor, crie um arquivo .env na raiz do seu projeto e adicione 'GOOGLE_API_KEY=SUA_CHAVE_AQUI'.")
    st.info("Voc√™ pode obter sua chave em [https://aistudio.google.com/app/apikey](https://aistudio.google.com/app/apikey)")
    logging.error("GOOGLE_API_KEY n√£o configurada. O aplicativo n√£o pode continuar.")
    st.stop()

# --- Dicion√°rios de Refer√™ncia da OWASP ---
OWASP_TOP_10_2021 = {
    "A01": "Broken Access Control",
    "A02": "Cryptographic Failures",
    "A03": "Injection",
    "A04": "Insecure Design",
    "A05": "Security Misconfiguration",
    "A06": "Vulnerable and Outdated Components",
    "A07": "Identification and Authentication Failures",
    "A08": "Software and Data Integrity Failures",
    "A09": "Security Logging and Monitoring Failures",
    "A10": "Server-Side Request Forgery (SSRF)"
}

OWASP_API_TOP_10_2023 = {
    "API1": "Broken Object Level Authorization (BOLA)",
    "API2": "Broken Authentication",
    "API3": "Broken Object Property Level Authorization",
    "API4": "Unrestricted Resource Consumption",
    "API5": "Broken Function Level Authorization (BFLA)",
    "API6": "Unrestricted Access to Sensitive Business Flows",
    "API7": "Server Side Request Forgery (SSRF)",
    "API8": "Security Misconfiguration",
    "API9": "Improper Inventory Management",
    "API10": "Unsafe Consumption of APIs"
}

# NOVO: OWASP Mobile Top 10 (2024 - vers√£o comum, se houver atualiza√ß√£o, ajuste)
OWASP_MOBILE_TOP_10_2024 = {
    "M1": "Improper Credential Usage",
    "M2": "Insecure Communication",
    "M3": "Insecure Authorization",
    "M4": "Insecure Provisioning",
    "M5": "Insufficient Cryptography",
    "M6": "Insecure Data Storage",
    "M7": "Insecure Authentication",
    "M8": "Insufficient Code Integrity",
    "M9": "Improper Session Handling",
    "M10": "Lack of Binary Protections"
}


OWASP_SUBCATEGORIES = {
    "A01": [
        "Insecure Direct Object References (IDOR)", "Missing Function Level Access Control",
        "Privilege Escalation (Vertical/Horizontal)", "Path Traversal",
        "URL Tampering", "Parameter Tampering"
    ],
    "A02": [
        "Weak Hashing Algorithms", "Use of Outdated/Weak Encryption Protocols (e.g., TLS 1.0/1.1)",
        "Hardcoded Cryptographic Keys", "Improper Key Management",
        "Exposure of Sensitive Data in Transit/At Rest"
    ],
    "A03": [
        "SQL Injection (SQLi)", "Cross-Site Scripting (XSS)",
        "Command Injection", "LDAP Injection", "XPath Injection",
        "NoSQL Injection", "Server-Side Template Injection (SSTI)",
        "Code Injection (e.g., PHP, Python, Java)", "Header Injection (e.g., Host Header Injection)"
    ],
    "A04": [
        "Business Logic Flaws", "Lack of Security Design Principles",
        "Trust Boundary Violations", "Feature Overload",
        "Insecure Direct Object References (IDOR) - (also A01, design aspect)"
    ],
    "A05": [
        "Default Passwords/Configurations", "Unnecessary Features/Services Enabled",
        "Improper File/Directory Permissions", "Missing Security Headers",
        "Error Messages Revealing Sensitive Information", "Open Cloud Storage Buckets"
    ],
    "A06": [
        "Using Libraries/Frameworks with Known Vulnerabilities", "Outdated Server Software (e.g., Apache, Nginx, IIS)",
        "Client-Side Libraries with Vulnerabilities", "Lack of Patch Management"
    ],
    "A07": [
        "Weak Password Policies", "Missing Multi-Factor Authentication (MFA)",
        "Session Management Flaws (e.g., fixed session IDs)", "Improper Credential Recovery Mechanisms",
        "Brute-Force Attacks (lack of rate limiting)"
    ],
    "A08": [
        "Insecure Deserialization", "Lack of Integrity Checks on Updates/Packages",
        "Weak Digital Signatures", "Client-Side Trust (e.g., relying on client-side validation)"
    ],
    "A09": [
        "Insufficient Logging of Security Events", "Lack of Alerting on Suspicious Activities",
        "Inadequate Retention of Logs", "Logs Not Protected from Tampering"
    ],
    "A10": "Server-Side Request Forgery (SSRF)"
}


# --- Fun√ß√µes Auxiliares Comuns ---

def get_verbosity_prompt():
    """Retorna a instru√ß√£o de prompt baseada na verbosidade selecionada."""
    verbosity = st.session_state.get('llm_verbosity', "Detalhado (T√©cnico)")
    
    if verbosity == "Conciso (Resumo Executivo)":
        return "Instru√ß√£o de Verbosidade: Seja extremamente conciso e foque no impacto para o neg√≥cio. Evite jarg√µes t√©cnicos profundos. A resposta deve ser adequada para um executivo (C-Level)."
    elif verbosity == "Super Detalhado (Educacional)":
        return "Instru√ß√£o de Verbosidade: Seja extremamente detalhado em suas explica√ß√µes. Defina cada conceito t√©cnico como se estivesse ensinando um iniciante. Forne√ßa m√∫ltiplos exemplos e um contexto aprofundado."
    else: # Padr√£o: "Detalhado (T√©cnico)"
        return "Instru√ß√£o de Verbosidade: Forne√ßa uma resposta t√©cnica completa e precisa, adequada para uma equipe de desenvolvimento ou seguran√ßa. Use jarg√µes t√©cnicos apropriadamente."


def get_log_file_content(log_file_path='huntia.log'):
    """L√™ o conte√∫do do arquivo de log."""
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    return "Log file not found."


def is_valid_url(url_string):
    """Verifica se a string √© uma URL bem formada."""
    if not url_string:
        return False
    try:
        result = urlparse(url_string)
        # Verifica se h√° esquema (http, https) e network location (dom√≠nio)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False


def get_gemini_models_cached():
    if 'llm_models' not in st.session_state:
        st.session_state.llm_models = {'vision_model': None, 'text_model': None, 'initialized': False}

    if not st.session_state.llm_models['initialized']:
        genai.configure(api_key=API_KEY)

        llm_model_vision_temp = None
        llm_model_text_temp = None

        vision_model_priority = ["gemini-1.5-flash", "gemini-1.5-pro", "gemini-pro-vision"]
        text_model_priority = ["gemini-1.5-flash", "gemini-1.5-pro", "gemini-pro"]

        try:
            available_models = list(genai.list_models())

            for preferred_name in vision_model_priority:
                for m in available_models:
                    if preferred_name in m.name and 'generateContent' in m.supported_generation_methods:
                        llm_model_vision_temp = genai.GenerativeModel(m.name)
                        break
                if llm_model_vision_temp:
                    break

            for preferred_name in text_model_priority:
                for m in available_models:
                    if preferred_name in m.name and 'generateContent' in m.supported_generation_methods:
                        llm_model_text_temp = genai.GenerativeModel(m.name, generation_config={"temperature": LLM_TEMPERATURE})
                        break
                if llm_model_text_temp:
                    break

            if not llm_model_vision_temp:
                st.error("ERRO: Nenhum modelo LLM de vis√£o adequado (gemini-1.5-flash/pro ou gemini-pro-vision) encontrado.")
                st.info("Por favor, configure sua GOOGLE_API_KEY e verifique a disponibilidade de modelos no Google AI Studio.")
                logging.error("Nenhum modelo LLM de vis√£o adequado encontrado.")
            if not llm_model_text_temp:
                st.error("ERRO: Nenhum modelo LLM de texto adequado (gemini-1.5-flash/pro ou gemini-pro) encontrado.")
                st.info("Por favor, configure sua GOOGLE_API_KEY e verifique a disponibilidade de modelos no Google AI Studio.")
                logging.error("Nenhum modelo LLM de texto adequado encontrado.")

        except Exception as e:
            st.error(f"ERRO ao listar ou selecionar modelos do Gemini: {e}")
            st.info("Verifique sua conex√£o com a internet e sua GOOGLE_API_KEY.")
            logging.exception("Erro ao listar ou selecionar modelos do Gemini.")

        st.session_state.llm_models['vision_model'] = llm_model_vision_temp
        st.session_state.llm_models['text_model'] = llm_model_text_temp
        st.session_state.llm_models['initialized'] = True
    
    return st.session_state.llm_models['vision_model'], st.session_state.llm_models['text_model']


def obter_resposta_llm(model_instance, prompt_parts):
    if model_instance is None:
        st.error("Erro: O modelo LLM n√£o foi inicializado corretamente. N√£o √© poss√≠vel gerar conte√∫do.")
        logging.error("Tentativa de gerar conte√∫do com modelo LLM n√£o inicializado.")
        return None
    try:
        response = model_instance.generate_content(prompt_parts)
        logging.info(f"Resposta do LLM obtida com sucesso do modelo {model_instance.model_name}.")
        return response.text
    except Exception as e:
        st.error(f"Erro ao comunicar com o LLM: {e}")
        st.info("Verifique se a sua conex√£o com a internet est√° ativa e se o modelo LLM est√° funcionando.")
        logging.exception(f"Erro ao comunicar com o LLM {model_instance.model_name}.")
        return None

def formatar_resposta_llm(resposta_bruta):
    return resposta_bruta

@st.cache_data(show_spinner=False)

def mapear_falha_para_owasp(_llm_text_model, falha_input):
    owasp_list = "\n".join([f"{code}: {name}" for code, name in OWASP_TOP_10_2021.items()])

    prompt = (
        f"Qual categoria da OWASP Top 10 (2021) melhor representa a vulnerabilidade ou t√©cnica de ataque '{falha_input}'?"
        f"\n\nConsidere a seguinte lista de categorias OWASP Top 10 (2021):"
        f"\n{owasp_list}"
        f"\n\nSe a entrada for um nome de falha espec√≠fica (como 'XSS', 'SQL Injection', 'IDOR'), identifique a categoria correta e retorne apenas o C√ìDIGO (ex: A03)."
        f"Se a entrada for j√° um c√≥digo OWASP (ex: 'A01'), retorne-o diretamente."
        f"Se n√£o tiver certeza ou se n√£o se encaixar em nenhuma categoria clara, responda 'INDEFINIDO'."
        f"\nExemplos: 'SQL Injection' -> 'A03', 'Cross-Site Scripting' -> 'A03', 'IDOR' -> 'A01', 'Broken Access Control' -> 'A01', 'Clickjacking' -> 'A04', 'A03' -> 'A03'."
        f"\nResposta esperada √© APENAS o c√≥digo OWASP."
    )

    with st.spinner(f"Tentando mapear '{falha_input}' para uma categoria OWASP..."):
        logging.info(f"Tentando mapear '{falha_input}' para categoria OWASP.")
        resposta = obter_resposta_llm(_llm_text_model, [prompt])

    if resposta:
        codigo_owasp = resposta.strip().upper().split(':')[0].split(' ')[0]
        if codigo_owasp in OWASP_TOP_10_2021:
            logging.info(f"Mapeado '{falha_input}' para OWASP {codigo_owasp}.")
            return codigo_owasp
        elif codigo_owasp == "INDEFINIDO":
            st.warning("O LLM n√£o conseguiu mapear a falha para uma categoria OWASP espec√≠fica.")
            logging.warning(f"LLM n√£o mapeou '{falha_input}' para categoria OWASP (INDEFINIDO).")
            return None
        else:
            st.warning(f"O LLM retornou um c√≥digo inesperado: '{codigo_owasp}'.")
            logging.warning(f"LLM retornou c√≥digo inesperado '{codigo_owasp}' para '{falha_input}'.")
            return None
    logging.warning(f"Nenhuma resposta do LLM para mapeamento OWASP de '{falha_input}'.")
    return None

def parse_vulnerability_summary(text_response):
    summary = {
        "Total": 0, "Cr√≠ticas": 0, "Altas": 0, "M√©dias": 0, "Baixas": 0
    }

    lines = text_response.split('\n')
    summary_line_found = False
    parsed_content = []

    for i, line in enumerate(lines):
        # Esta √© a linha que procura pela linha de resumo.
        # Adicione "Total de Achados Mobile:" para garantir que o parser encontre a linha no caso mobile.
        if ("Total de Vulnerabilidades:" in line or "Total de Amea√ßas:" in line or \
            "Total de Vulnerabilidades API:" in line or "Total de Insights:" in line or \
            "Total de Eventos:" in line or "Total de Achados:" in line or \
            "Total de Achados de Valida√ß√£o:" in line or "Total de Achados Mobile:" in line or \
            "Total Achados:" in line) and not summary_line_found: # Adicione "Total Achados:" para o caso espec√≠fico da imagem
            summary_line = line
            summary_line_found = True
        else:
            parsed_content.append(line)

    if summary_line_found:
        # Usar regexes mais flex√≠veis para capturar os n√∫meros ap√≥s os r√≥tulos
        total_match = re.search(r'Total(?: de Achados| de Vulnerabilidades| de Amea√ßas| de Insights| de Eventos| de Achados de Valida√ß√£o| Mobile)?:\s*(\d+)', summary_line)
        crit_match = re.search(r'Cr√≠ticas?:\s*(\d+)', summary_line) # Suporta Cr√≠ticas: ou Cr√≠ticos:
        altas_match = re.search(r'Altas?:\s*(\d+)', summary_line) # Suporta Altas: ou Altos:
        medias_match = re.search(r'M√©dios?:\s*(\d+)', summary_line) # Suporta M√©dias: ou M√©dios:
        baixas_match = re.search(r'Baixas?:\s*(\d+)', summary_line) # Suporta Baixas: ou Baixos:

        if total_match:
            summary["Total"] = int(total_match.group(1))
        if crit_match:
            summary["Cr√≠ticas"] = int(crit_match.group(1))
        if altas_match:
            summary["Altas"] = int(altas_match.group(1))
        if medias_match:
            summary["M√©dias"] = int(medias_match.group(1))
        if baixas_match:
            summary["Baixas"] = int(baixas_match.group(1))
            
        # Para os campos de valida√ß√£o de pentest (se ainda forem usados, mantenha)
        cobertura_alta_match = re.search(r'Cobertura Alta:\s*(\d+)', summary_line)
        cobertura_media_match = re.search(r'Cobertura M√©dia:\s*(\d+)', summary_line)
        cobertura_baixa_match = re.search(r'Cobertura Baixa:\s*(\d+)', summary_line)
        lacunas_match = re.search(r'Lacunas:\s*(\d+)', summary_line)

        if cobertura_alta_match:
            summary["Cobertura Alta"] = int(cobertura_alta_match.group(1))
        if cobertura_media_match:
            summary["Cobertura M√©dia"] = int(cobertura_media_match.group(1))
        if cobertura_baixa_match:
            summary["Cobertura Baixa"] = int(cobertura_baixa_match.group(1))
        if lacunas_match:
            summary["Lacunas"] = int(lacunas_match.group(1))

    return summary, "\n".join(parsed_content).strip()

def parse_raw_http_request(raw_request):
    method = ""
    path = ""
    full_url = ""
    headers = {}
    body = ""

    lines = raw_request.splitlines()

    # Parse first line (method, path, HTTP version)
    if lines and lines[0].strip():
        first_line_parts = lines[0].split(' ')
        if len(first_line_parts) >= 2:
            method = first_line_parts[0].strip()
            path = first_line_parts[1].strip()

    body_started = False
    for line in lines[1:]:
        if not line.strip() and not body_started: # Empty line indicates end of headers, start of body
            body_started = True
            continue

        if not body_started: # Still parsing headers
            if ':' in line:
                key, value = line.split(':', 1)
                headers[key.strip()] = value.strip()
        else: # Parsing body
            body += line + '\n'

    # Try to construct full_url from Host header and path
    if 'Host' in headers and path:
        host = headers['Host']
        # Determine scheme based on common ports or explicitly in request line
        scheme = "https" if "443" in host or raw_request.lower().splitlines()[0].startswith("https") else "http"
        # Handle cases where path might already include domain, or just be a root path
        if path.startswith('http://') or path.startswith('https://'):
            full_url = path # Path is already a full URL
        elif path.startswith('/'):
            full_url = f"{scheme}://{host}{path}"
        else: # Relative path without leading slash, assume it follows host directly
            full_url = f"{scheme}://{host}/{path}" # Add a slash for safety

    return {
        "method": method,
        "path": path,
        "full_url": full_url,
        "headers": headers,
        "body": body.strip()
    }


# --- Fun√ß√µes das "P√°ginas" --- (Defini√ß√£o de todas as fun√ß√µes antes de main())

def home_page():
    st.header("Bem-vindo ao HuntIA - Plataforma de Seguran√ßa üõ°Ô∏è")
    st.markdown("---")
    
    # Mensagem de status para guiar o usu√°rio sobre como come√ßar
    st.info("""
        **Comece pela p√°gina de 'Configura√ß√µes' na barra lateral para:**
        - Criar ou selecionar um projeto para salvar seu trabalho.
        - Ativar o 'Modo Rascunho' para an√°lises r√°pidas e n√£o salvas.
        - Definir o contexto global do pentest (Perfil do Atacante e Cen√°rio).
    """)

    st.markdown("""
        ### Sua su√≠te de reconhecimento e pentest inteligente, com o poder do LLM!
        
        Ap√≥s configurar sua sess√£o, selecione uma das ferramentas na barra lateral para iniciar sua an√°lise.
    """)
    logging.info("P√°gina inicial acessada.")

def get_global_context_prompt():
    """Retorna a string de contexto global a ser injetada nos prompts do LLM."""
    profile = st.session_state.get('global_profile', "Nenhum")
    scenario = st.session_state.get('global_scenario', "Nenhum")
    
    context_parts = []
    if profile != "Nenhum":
        context_parts.append(f"com um perfil de atacante '{profile}'")
    if scenario != "Nenhum":
        context_parts.append(f"em um cen√°rio de ataque de '{scenario}'")
    
    if context_parts:
        # Instru√ß√£o mais detalhada para o LLM usar o contexto
        return f"Considere-se atuando como um pentester {', e '.join(context_parts)}. Ajuste suas respostas com base nesse conhecimento, fornecendo retornos como se fosse um especialista nesse contexto, priorizando a profundidade e o tipo de vulnerabilidades, m√©todos de explora√ß√£o e mitiga√ß√µes que seriam relevantes para esse contexto espec√≠fico."
    return "Considere-se um pentester gen√©rico e experiente, fornecendo respostas abrangentes." # Contexto padr√£o se nada for selecionado

# C√ìDIGO ATUALIZADO para correlation_dashboard_page
def settings_page():
    st.header("Configura√ß√µes Globais e Gerenciamento de Projetos ‚öôÔ∏è")
    st.markdown("---")

    # --- Se√ß√£o de Controle de Comportamento do LLM ---
    st.subheader("Controle de Comportamento do LLM")

    # Inicializa o estado da verbosidade se n√£o existir
    if 'llm_verbosity' not in st.session_state:
        st.session_state.llm_verbosity = "Detalhado (T√©cnico)" # Valor padr√£o

    st.session_state.llm_verbosity = st.selectbox(
        "Modo de Verbosidade do Relat√≥rio:",
        options=["Conciso (Resumo Executivo)", "Detalhado (T√©cnico)", "Super Detalhado (Educacional)"],
        index=["Conciso (Resumo Executivo)", "Detalhado (T√©cnico)", "Super Detalhado (Educacional)"].index(st.session_state.llm_verbosity),
        help="Define o n√≠vel de detalhe das respostas do LLM em toda a aplica√ß√£o."
    )
    st.markdown("---")
    
    # --- Se√ß√£o de Modo de Opera√ß√£o ---
    st.subheader("Modo de Opera√ß√£o")
    
    if 'modo_rascunho' not in st.session_state: 
        st.session_state.modo_rascunho = True

    st.session_state.modo_rascunho = st.checkbox(
        "Ativar Modo Rascunho (N√£o Salvar An√°lises)", 
        value=st.session_state.modo_rascunho,
        help="Quando ativado, voc√™ pode usar as ferramentas sem selecionar um projeto, e os resultados n√£o ser√£o salvos no banco de dados."
    )

    if st.session_state.modo_rascunho:
        st.info("Modo Rascunho Ativo ‚úèÔ∏è: Os resultados das an√°lises n√£o ser√£o salvos.")
    else:
        st.success("Modo de Projeto Ativo üíæ: Os resultados das an√°lises ser√£o salvos no projeto selecionado.")
    
    st.markdown("---")

    # --- Se√ß√£o do Gerenciador de Projetos ---
    st.subheader("Gerenciador de Projetos")

    is_disabled = st.session_state.modo_rascunho

    if is_disabled:
        st.warning("O gerenciamento de projetos est√° desabilitado pois o Modo Rascunho est√° ativo.")

    lista_de_projetos = database.listar_projetos()
    opcoes_projetos = {nome: id for id, nome in lista_de_projetos}
    nomes_projetos_para_selectbox = ["Nenhum"] + list(opcoes_projetos.keys())

    try:
        index_selecionado = nomes_projetos_para_selectbox.index(st.session_state.projeto_ativo_nome) if st.session_state.projeto_ativo_nome else 0
    except ValueError:
        index_selecionado = 0

    col1, col2 = st.columns(2)
    with col1:
        projeto_selecionado_nome = st.selectbox(
            "Selecione um Projeto Ativo:",
            options=nomes_projetos_para_selectbox,
            index=index_selecionado,
            key="project_selector_settings_page",
            disabled=is_disabled
        )

        if not is_disabled:
            if projeto_selecionado_nome and projeto_selecionado_nome != "Nenhum":
                if st.session_state.projeto_ativo_nome != projeto_selecionado_nome:
                    st.session_state.projeto_ativo_id = opcoes_projetos[projeto_selecionado_nome]
                    st.session_state.projeto_ativo_nome = projeto_selecionado_nome
                    logging.info(f"Projeto '{projeto_selecionado_nome}' selecionado.")
                    st.rerun()
            elif st.session_state.projeto_ativo_nome and projeto_selecionado_nome == "Nenhum":
                st.session_state.projeto_ativo_id = None
                st.session_state.projeto_ativo_nome = None
                st.rerun()
    
    with col2:
        novo_projeto_nome = st.text_input("Ou crie um novo projeto:", key="new_project_input_settings_page", disabled=is_disabled)
        if st.button("Criar Projeto", key="create_project_button_settings_page", disabled=is_disabled):
            if novo_projeto_nome:
                sucesso, novo_projeto_id, mensagem = database.criar_projeto(novo_projeto_nome)
                if sucesso:
                    st.toast(mensagem, icon="üéâ")
                    st.session_state.projeto_ativo_nome = novo_projeto_nome
                    st.session_state.projeto_ativo_id = novo_projeto_id
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error(mensagem)
            else:
                st.warning("Digite um nome para o novo projeto.")
    
    st.markdown("---")

    # --- Se√ß√£o de Contexto Global ---
    st.subheader("Contexto da An√°lise (Engenharia de Prompt)")
    col_profile, col_scenario = st.columns(2)

    with col_profile:
        st.session_state.global_profile = st.selectbox(
            "Perfil do Atacante:",
            options=["Nenhum", "Novato", "Experiente", "APT (Advanced Persistent Threat)"],
            index=["Nenhum", "Novato", "Experiente", "APT (Advanced Persistent Threat)"].index(st.session_state.get('global_profile', 'Nenhum')),
            key="global_profile_select_settings"
        )
    with col_scenario:
        st.session_state.global_scenario = st.selectbox(
            "Cen√°rio de Ataque:",
            options=["Nenhum", "Acesso Interno", "Acesso Externo (Internet)", "Phishing", "Red Team Exercise"],
            index=["Nenhum", "Acesso Interno", "Acesso Externo (Internet)", "Phishing", "Red Team Exercise"].index(st.session_state.get('global_scenario', 'Nenhum')),
            key="global_scenario_select_settings"
        )

def correlation_dashboard_page(llm_model_text):
    st.header("Correlation Dashboard: Conectando os Pontos üß†")
    st.markdown("""
        Esta p√°gina atua como o c√©rebro central do seu projeto. Ela agrega os resultados de todas as outras
        ferramentas e usa o LLM para identificar correla√ß√µes de risco e vetores de ataque combinados
        que poderiam passar despercebidos em an√°lises isoladas.
    """)
    logging.info("P√°gina Correlation Dashboard acessada.")

    if 'correlation_result' not in st.session_state:
        st.session_state.correlation_result = ""

    if not st.session_state.get('projeto_ativo_id'):
        st.error("Por favor, selecione ou crie um projeto na barra lateral para usar este m√≥dulo.")
        st.stop()
    
    st.info(f"Analisando correla√ß√µes para o projeto: **{st.session_state.projeto_ativo_nome}**")

    # 1. Agrega√ß√£o de Dados do Projeto Ativo
    st.subheader("1. Resumo dos Dados Coletados para o Projeto")
    
    # Carregar todas as an√°lises salvas do banco de dados para o projeto atual
    analises_salvas = database.carregar_analises_do_projeto(st.session_state.projeto_ativo_id)
    
    dados_agregados_para_prompt = []
    dados_para_exibir = []

    if not analises_salvas:
        st.warning("Nenhuma an√°lise foi salva neste projeto ainda. Por favor, use as outras ferramentas primeiro para gerar dados.")
        st.stop()

    # --- IN√çCIO DA MODIFICA√á√ÉO (Processar os novos tipos de an√°lise) ---
    for tipo_analise, resumo_input, resultado_completo in analises_salvas:
        # Adiciona um resumo para exibi√ß√£o no dashboard
        dados_para_exibir.append(f"**Fonte:** `{tipo_analise}`\n**Input:** {resumo_input}\n")
        
        # Adiciona um resumo mais detalhado para o prompt do LLM
        # Para an√°lises de texto, o resumo do input √© suficiente
        if tipo_analise in ["OWASP Vulnerability Details", "Static Code Analyzer", "OpenAPI Analyzer"]:
             dados_agregados_para_prompt.append(f"**Achado de '{tipo_analise}':**\n{resumo_input}\n")
        # Para o Deep HTTP Insight, podemos extrair a tabela de riscos para o prompt
        elif tipo_analise == "Deep HTTP Insight":
            tabela_riscos_match = re.search(r"## Tabela de Riscos\n(.*?)(?=\n##|\Z)", resultado_completo, re.DOTALL | re.IGNORECASE)
            if tabela_riscos_match:
                tabela_formatada = tabela_riscos_match.group(1).strip()
                dados_agregados_para_prompt.append(f"**Achado de '{tipo_analise}':**\n{resumo_input}\n**Tabela de Riscos Identificados:**\n{tabela_formatada}\n")
            else:
                dados_agregados_para_prompt.append(f"**Achado de '{tipo_analise}':**\n{resumo_input}\n")
        else:
            # Fallback para outros tipos de an√°lise
            dados_agregados_para_prompt.append(f"**Achado de '{tipo_analise}':**\n{resumo_input}\n")
    # --- FIM DA MODIFICA√á√ÉO ---

    with st.expander("Clique para ver os dados agregados que ser√£o enviados para an√°lise"):
        for dado in dados_para_exibir:
            st.markdown(dado)
            st.markdown("---")

    st.subheader("2. An√°lise de Correla√ß√£o de Risco")
    if st.button("Analisar Correla√ß√µes", key="analyze_correlations_button"):
        with st.spinner("O HuntIA est√° pensando e conectando os pontos..."):
            logging.info(f"Correlation Dashboard: Iniciando an√°lise de correla√ß√£o para o projeto ID {st.session_state.projeto_ativo_id}.")
            
            global_context_prompt = get_global_context_prompt()
            
            correlation_prompt = (
                "Voc√™ √© um analista de seguran√ßa s√™nior e um 'Threat Hunter', especializado em conectar pontos e identificar vetores de ataque complexos."
                f"{global_context_prompt}\n\n"
                "A seguir est√£o os resumos de v√°rias an√°lises de seguran√ßa realizadas em um mesmo projeto. "
                "Sua miss√£o √© atuar como um 'meta-analisador'. Analise TODOS os achados em conjunto. "
                "Sua tarefa N√ÉO √© repetir os achados, mas sim encontrar **correla√ß√µes, depend√™ncias e vetores de ataque combinados** que um analista olhando para cada ferramenta isoladamente poderia perder.\n\n"
                "**Dados Agregados para An√°lise:**\n"
                "```\n"
                f"{'\n\n'.join(dados_agregados_para_prompt)}"
                "\n```\n\n"
                "**Formato da Resposta:**\n"
                "Forne√ßa sua an√°lise em uma lista de vetores de ataque correlacionados. Para cada um, use o seguinte formato Markdown:\n\n"
                "### Vetor de Ataque Correlacionado #[N√∫mero]\n"
                "**Descri√ß√£o do Vetor:** (Descreva o cen√°rio de ataque combinado de forma clara e concisa).\n"
                "**Pontos de Conex√£o:** (Explique exatamente quais achados de diferentes ferramentas se conectam. Ex: 'A resposta HTTP do *Deep HTTP Insight* mostrou um cabe√ßalho 'Server: Apache/2.4.29'. A consulta no *OWASP Vulnerability Details* sobre 'vulnerabilidades Apache 2.4.29' pode revelar exploits conhecidos para esta vers√£o.').\n"
                "**Pr√≥ximo Passo T√°tico Sugerido:** (Sugira a pr√≥xima a√ß√£o pr√°tica que um pentester deveria tomar. Ex: 'Use o Tactical Command Orchestrator para gerar um comando `nmap -sV --script http-vuln-cve*` contra o alvo para confirmar as vulnerabilidades conhecidas.').\n"
                "**N√≠vel de Risco da Correla√ß√£o:** [Cr√≠tico/Alto/M√©dio]\n"
                "---"
            )

            correlation_raw = obter_resposta_llm(llm_model_text, [correlation_prompt])
            
            if correlation_raw:
                st.session_state.correlation_result = correlation_raw
                logging.info(f"Correlation Dashboard: An√°lise de correla√ß√£o conclu√≠da com sucesso para o projeto ID {st.session_state.projeto_ativo_id}.")
                # Salva a pr√≥pria an√°lise de correla√ß√£o no banco de dados
                try:
                    database.salvar_analise(
                        projeto_id=st.session_state.projeto_ativo_id,
                        tipo_analise="Correlation Analysis",
                        resumo_input=f"Correla√ß√£o baseada em {len(dados_para_exibir)} achados do projeto.",
                        resultado_completo=correlation_raw
                    )
                    st.toast("An√°lise de correla√ß√£o salva no projeto!", icon="üß†")
                except Exception as e:
                    st.error(f"Houve um erro ao salvar a an√°lise de correla√ß√£o no banco de dados: {e}")
            else:
                st.session_state.correlation_result = "N√£o foi poss√≠vel obter uma an√°lise de correla√ß√£o. Tente novamente."
                logging.error(f"Correlation Dashboard: Falha ao obter an√°lise de correla√ß√£o do LLM para o projeto ID {st.session_state.projeto_ativo_id}.")
                
    if st.session_state.correlation_result:
        st.markdown(st.session_state.correlation_result)
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="correlation_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Correlation Dashboard: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="correlation_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Correlation Dashboard: Precisa de Melhoria.")

def owasp_scout_visual_page(llm_model_vision, llm_model_text):
    st.header("OWASP Image Analyzer: An√°lise de Vulnerabilidades em Imagens üëÅÔ∏è")
    st.markdown("""
        Envie um print, um trecho de c√≥digo em imagem, ou qualquer diagrama e pergunte ao HuntIA se ele detecta vulnerabilidades OWASP Top 10.
        Quanto mais detalhes na sua pergunta, melhor a an√°lise!
    """)
    logging.info("P√°gina OWASP Image Analyzer acessada.")

    # --- In√≠cio do Bloco Universal de Verifica√ß√£o ---
    if not st.session_state.get('projeto_ativo_id') and not st.session_state.get('modo_rascunho'):
        st.error("Por favor, selecione um projeto ou ative o 'Modo Rascunho' na p√°gina de Configura√ß√µes.")
        st.stop()
    
    if st.session_state.get('modo_rascunho'):
        st.info("Voc√™ est√° no Modo Rascunho. Esta an√°lise n√£o ser√° salva. ‚úèÔ∏è")
    else:
        st.success(f"Analisando imagens para o projeto: **{st.session_state.projeto_ativo_nome}**")
    st.markdown("---")
    # --- Fim do Bloco Universal ---

    # Initialize session state variables for this page
    if 'owasp_image_uploaded_list' not in st.session_state:
        st.session_state.owasp_image_uploaded_list = []
    if 'owasp_question_text' not in st.session_state:
        st.session_state.owasp_question_text = ""
    if 'owasp_analysis_result' not in st.session_state:
        st.session_state.owasp_analysis_result = ""
    if 'owasp_consider_waf_state' not in st.session_state:
        st.session_state.owasp_consider_waf_state = False

    def reset_owasp_scout_visual():
        st.session_state.owasp_image_uploaded_list = []
        st.session_state.owasp_question_text = ""
        st.session_state.owasp_analysis_result = ""
        st.session_state.owasp_consider_waf_state = False
        logging.info("OWASP Image Analyzer: Reset de campos.")
        st.rerun()

    if st.button("Limpar e Fazer Nova Consulta", key="reset_visual_analysis_button"):
        reset_owasp_scout_visual()

    uploaded_files = st.file_uploader(
        "Selecione uma ou mais imagens para an√°lise (JPG, JPEG, PNG)",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        key="owasp_file_uploader"
    )

    if uploaded_files:
        existing_file_fingerprints = {(e['name'], e['image'].size) for e in st.session_state.owasp_image_uploaded_list if 'name' in e and 'image' in e}
        
        for uploaded_file in uploaded_files:
            try:
                img_bytes = uploaded_file.getvalue()
                img = Image.open(BytesIO(img_bytes))
                
                file_fingerprint = (uploaded_file.name, img.size)
                
                if file_fingerprint not in existing_file_fingerprints:
                    st.session_state.owasp_image_uploaded_list.append({
                        'image': img,
                        'name': uploaded_file.name,
                        'id': str(uuid.uuid4())
                    })
                    existing_file_fingerprints.add(file_fingerprint)
                    logging.info(f"OWASP Image Analyzer: Imagem '{uploaded_file.name}' carregada.")
                else:
                    st.info(f"Arquivo '{uploaded_file.name}' j√° carregado. Ignorando duplicata.")
            except Exception as e:
                st.error(f"Erro ao carregar a imagem {uploaded_file.name}: {e}")
                logging.error(f"OWASP Image Analyzer: Erro ao carregar imagem '{uploaded_file.name}': {e}")

    if st.session_state.owasp_image_uploaded_list:
        st.markdown("#### Imagens Carregadas:")
        images_to_remove = []
        for i, img_data in enumerate(st.session_state.owasp_image_uploaded_list):
            col1, col2 = st.columns([3, 1])
            with col1:
                st.image(img_data['image'], caption=f"Pr√©-visualiza√ß√£o Imagem {i+1}: {img_data.get('name', 'N/A')}", use_container_width=True)
            with col2:
                if st.button(f"Remover Imagem {i+1}", key=f"remove_owasp_img_btn_{img_data['id']}"):
                    images_to_remove.append(i)
        
        if images_to_remove:
            for index in sorted(images_to_remove, reverse=True):
                logging.info(f"OWASP Image Analyzer: Imagem '{st.session_state.owasp_image_uploaded_list[index].get('name', 'N/A')}' removida.")
                del st.session_state.owasp_image_uploaded_list[index]
            st.rerun()

    question = st.text_area(
        "Sua pergunta sobre a vulnerabilidade ou contexto:",
        value=st.session_state.owasp_question_text,
        placeholder="Ex: 'Esta tela de login √© vulner√°vel?', 'H√° XSS neste c√≥digo?', 'Qual vulnerabilidade est√° presente neste diagrama?'",
        key="owasp_question_input"
    )
    st.session_state.owasp_question_text = question

    consider_waf = st.checkbox(
        "Considerar bypass de WAF?",
        value=st.session_state.owasp_consider_waf_state,
        key="owasp_waf_checkbox"
    )

    if st.button("Analisar Vulnerabilidade", key="owasp_analyze_button_main"):
        if not st.session_state.owasp_image_uploaded_list:
            st.error("Por favor, selecione pelo menos uma imagem para an√°lise.")
            return
        elif not st.session_state.owasp_question_text:
            st.error("Por favor, digite sua pergunta sobre a vulnerabilidade nas imagens.")
            return
        else:
            with st.spinner("Analisando suas imagens em busca de vulnerabilidades OWASP..."):
                logging.info(f"OWASP Image Analyzer: Iniciando an√°lise para '{st.session_state.owasp_question_text}' com {len(st.session_state.owasp_image_uploaded_list)} imagens.")

                # --- In√≠cio das Melhorias de Prompt ---
                global_context_prompt = get_global_context_prompt()
                verbosity_prompt = get_verbosity_prompt()
                instrucao_chain_of_thought = (
                    "\n\n**Instru√ß√£o de Racioc√≠nio Interno:** Antes de formular sua resposta final, siga estes passos de an√°lise mentalmente: "
                    "1. Examine cada imagem individualmente e identifique os elementos t√©cnicos vis√≠veis (ex: formul√°rios, trechos de c√≥digo, URLs, nomes de par√¢metros, respostas de servidor). "
                    f"2. Com base na pergunta do usu√°rio ('{st.session_state.owasp_question_text}'), liste os vetores de ataque OWASP mais prov√°veis para os elementos identificados. "
                    "3. Para cada vetor de ataque potencial, formule uma hip√≥tese de como ele se aplicaria ao contexto visual espec√≠fico. "
                    "4. Apenas ap√≥s concluir essa an√°lise interna, construa a resposta final para o usu√°rio, seguindo estritamente o formato de sa√≠da e o n√≠vel de verbosidade solicitados."
                )
                # --- Fim das Melhorias de Prompt ---
                
                # Usando o seu prompt detalhado e injetando as novas instru√ß√µes
                llm_input_parts = [
                    f"Voc√™ √© um especialista em seguran√ßa da informa√ß√£o e pentest.",
                    f"{global_context_prompt}",
                    f"{verbosity_prompt}",
                    instrucao_chain_of_thought,
                    f"\n\n**Tarefa Principal:** Analise TODAS as imagens fornecidas e o seguinte contexto/pergunta: '{st.session_state.owasp_question_text}'.",
                    f"\n\nIdentifique poss√≠veis vulnerabilidades de seguran√ßa da informa√ß√£o relevantes para a OWASP Top 10 (2021) que possam ser inferidas das imagens ou do contexto fornecido.",
                    f"\n\n**Formato de Sa√≠da Solicitado:** Para cada vulnerabilidade identificada, forne√ßa os seguintes detalhes de forma concisa e pr√°tica, utilizando formato Markdown para t√≠tulos e blocos de c√≥digo:",
                    f"\n\n## 1. Detalhamento da Falha",
                    f"\nUma breve explica√ß√£o do que √© a vulnerabilidade, como ela ocorre e os cen√°rios comuns de impacto, **especificamente como se relaciona √†s imagens ou ao contexto.** If the vulnerability is visible in a specific image, mention which image (e.g., 'Na Imagem 1, ...').",
                    f"\n\n## 2. Categoria OWASP (2021)",
                    f"\nIndique o C√ìDIGO e o NOME da categoria da OWASP Top 10 (2021) √† qual esta vulnerabilidade pertence (ex: A03: Injection). Use a lista: {', '.join([f'{c}: {n}' for c, n in OWASP_TOP_10_2021.items()])}. Se for uma subcategoria, mencione-la tamb√©m.",
                    f"\n\n## 3. T√©cnicas de Explora√ß√£o Detalhadas",
                    f"\nDescreva passo a passo os m√©todos comuns e abordagens para testar e explorar esta vulnerabilidade, focando em como as imagens podem estar relacionadas. Seja did√°tico e pr√°tico.\n",
                    f"\n\n## 4. Ferramentas Sugeridas",
                    f"\nListe as ferramentas de seguran√ßa e pentest (ex: Burp Suite, Nmap, SQLmap, XSSer, Nessus, Nikto, Metasploit, etc.) que seriam √∫teis para descobrir e explorar esta vulnerabilidade, explicando brevemente como cada uma se aplicaria.\n",
                    f"\n\n## 5. Severidade",
                    f"\nClassifique a severidade desta vulnerabilidade: [Cr√≠tica/Alta/M√©dia/Baixa].\n",
                    f"\n\n## 6. Dicas de Explora√ß√£o / Pr√≥ximos Passos Pr√°ticos",
                    f"\nCom base na falha identificada e no contexto das imagens, forne√ßa dicas pr√°ticas e os pr√≥ximos passos que um pentester faria para explorar ou confirmar a falha. Inclua instru√ß√µes sobre como usar as ferramentas sugeridas e payloads de teste, se aplic√°vel. Seja acion√°vel.\n"
                ]

                if st.session_state.owasp_consider_waf_state:
                    llm_input_parts.append(f"\n\n## 7. Dicas de Bypass de WAF")
                    llm_input_parts.append(f"\nForne√ßa estrat√©gias, t√©cnicas e exemplos pr√°ticos (se aplic√°vel √† vulnerabilidade) para contornar ou evadir a detec√ß√£o de um Web Application Firewall (WAF) ao tentar explorar esta falha. Inclua exemplos de payloads ou modifica√ß√µes de requisi√ß√µes que podem ajudar a testar o presen√ßa ou bypass do WAF.")
                    poc_section_num = 8
                else:
                    poc_section_num = 7

                llm_input_parts.append(f"\n\n## {poc_section_num}. Prova de Conceito (PoC)")
                llm_input_parts.append(f"\nForne√ßa **exemplos pr√°ticos de comandos de terminal, requisi√ß√µes HTTP (com `curl` ou similar), ou payloads de c√≥digo (Python, JS, etc.)** que demonstrem a explora√ß√£o. Esses exemplos devem ser claros, prontos para uso (com pequenas adapta√ß√µes) e encapsulados em blocos de c√≥digo Markdown (` ``` `). Relacione o PoC √†s imagens ou contexto, se poss√≠vel.")

                llm_input_parts.append(f"\n\nSeu objetivo √© ser direto, √∫til e focado em a√ß√µes e informa√ß√µes completas para um pentester. Se as imagens n√£o contiverem vulnerabilidades √≥bvias, ou a pergunta for muito gen√©rica, indique isso de forma clara.")
                
                for img_data in st.session_state.owasp_image_uploaded_list:
                    llm_input_parts.append(img_data['image'])

                analysis_result = obter_resposta_llm(llm_model_vision, llm_input_parts)

                if analysis_result:
                    st.session_state.owasp_analysis_result = analysis_result
                    logging.info("OWASP Image Analyzer: An√°lise conclu√≠da com sucesso.")

                    # Padr√£o Universal de Salvamento
                    if not st.session_state.get('modo_rascunho', False):
                        try:
                            nomes_imagens = ", ".join([img['name'] for img in st.session_state.owasp_image_uploaded_list])
                            resumo_para_db = f"An√°lise de Imagem: '{st.session_state.owasp_question_text}' em [{nomes_imagens}]"
                            database.salvar_analise(
                                projeto_id=st.session_state.projeto_ativo_id,
                                tipo_analise="OWASP Image Analyzer",
                                resumo_input=resumo_para_db,
                                resultado_completo=analysis_result
                            )
                            st.toast("An√°lise de imagem salva com sucesso no projeto!", icon="üíæ")
                        except Exception as e:
                            st.error(f"Houve um erro ao salvar a an√°lise no banco de dados: {e}")
                    else:
                        st.toast("Modo Rascunho: Resultado n√£o salvo.", icon="‚úèÔ∏è")
                else:
                    st.session_state.owasp_analysis_result = "N√£o foi poss√≠vel obter uma resposta do Gemini. Tente novamente."
                    logging.error("OWASP Image Analyzer: Falha na obten√ß√£o da resposta do LLM.")

    if st.session_state.owasp_analysis_result:
        st.subheader("Resultados da An√°lise Visual")
        st.markdown(st.session_state.owasp_analysis_result)
        
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="owasp_visual_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback OWASP Image Analyzer: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="owasp_visual_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback OWASP Image Analyzer: Precisa de Melhoria.")

def owasp_text_analysis_page(llm_model_vision, llm_model_text):
    st.header("OWASP Vulnerability Details üìö")
    st.markdown("""
        Digite o C√ìDIGO de uma categoria OWASP Top 10 (ex: `A03`) ou o NOME de uma falha espec√≠fica (ex: `IDOR`, `XSS`, `SQL Injection`).
        O HuntIA fornecer√° detalhes completos sobre a vulnerabilidade.
    """)
    logging.info("P√°gina OWASP Vulnerability Details acessada.")

    # Bloco Universal de Verifica√ß√£o
    if not st.session_state.get('projeto_ativo_id') and not st.session_state.get('modo_rascunho'):
        st.error("Por favor, selecione um projeto ou ative o 'Modo Rascunho' na p√°gina de Configura√ß√µes.")
        st.stop()
    
    if st.session_state.get('modo_rascunho'):
        st.info("Voc√™ est√° no Modo Rascunho. Esta consulta n√£o ser√° salva. ‚úèÔ∏è")
    else:
        st.success(f"Consultando vulnerabilidades para o projeto: **{st.session_state.projeto_ativo_nome}**")
    st.markdown("---")

    # Initialize session state variables for this page
    if 'owasp_text_input_falha' not in st.session_state:
        st.session_state.owasp_text_input_falha = ""
    if 'owasp_text_analysis_result' not in st.session_state:
        st.session_state.owasp_text_analysis_result = ""
    if 'owasp_text_context_input' not in st.session_state:
        st.session_state.owasp_text_context_input = ""
    if 'owasp_text_consider_waf_state' not in st.session_state:
        st.session_state.owasp_consider_waf_state = False

    def reset_owasp_text_analysis():
        st.session_state.owasp_text_input_falha = ""
        st.session_state.owasp_text_analysis_result = ""
        st.session_state.owasp_text_context_input = ""
        st.session_state.owasp_consider_waf_state = False
        logging.info("OWASP Vulnerability Details: Reset de campos.")
        st.rerun()

    if st.button("Limpar e Fazer Nova Consulta", key="reset_text_analysis_button"):
        reset_owasp_text_analysis()

    user_input_falha = st.text_input(
        "Digite a falha ou categoria OWASP:",
        value=st.session_state.owasp_text_input_falha,
        placeholder="Ex: A01, Injection, IDOR, Cross-Site Scripting",
        key="text_input_falha"
    )
    st.session_state.owasp_text_input_falha = user_input_falha.strip()

    contexto_texto = st.text_area(
        "Contexto Adicional Livre (opcional, para refinar a falha espec√≠fica):",
        value=st.session_state.owasp_text_context_input,
        placeholder="Ex: 'aplica√ß√£o web em PHP', 'API REST com JWT', 'explora√ß√£o via SQLi no par√¢metro id'",
        height=150,
        key="text_context_input"
    )
    st.session_state.owasp_text_context_input = contexto_texto.strip()

    consider_waf_texto = st.checkbox(
        "Considerar bypass de WAF?",
        value=st.session_state.owasp_consider_waf_state,
        key="text_consider_waf_checkbox"
    )

    if st.button("Analisar Falha por Texto", key="analyze_text_button"):
        if not st.session_state.owasp_text_input_falha:
            st.error("Por favor, digite a falha ou categoria OWASP para an√°lise.")
            logging.warning("OWASP Vulnerability Details: An√°lise abortada, entrada de falha vazia.")
            return
        else:
            categoria_owasp_codigo = None
            specific_vulnerability_name = st.session_state.owasp_text_input_falha

            if specific_vulnerability_name.upper() in OWASP_TOP_10_2021:
                categoria_owasp_codigo = specific_vulnerability_name.upper()
                st.info(f"Categoria OWASP selecionada: {OWASP_TOP_10_2021[categoria_owasp_codigo]}")
            else:
                categoria_owasp_codigo = mapear_falha_para_owasp(llm_model_text, specific_vulnerability_name)
                if categoria_owasp_codigo:
                    st.info(f"O LLM mapeou '{specific_vulnerability_name}' para a categoria OWASP: {OWASP_TOP_10_2021[categoria_owasp_codigo]}")
                else:
                    st.error("N√£o foi poss√≠vel identificar a categoria OWASP para a falha fornecida.")
                    st.session_state.owasp_text_analysis_result = ""
                    return

            if categoria_owasp_codigo:
                with st.spinner(f"Obtendo informa√ß√µes para {specific_vulnerability_name}..."):
                    
                    global_context_prompt = get_global_context_prompt()
                    verbosity_prompt = get_verbosity_prompt()

                    prompt_base = (
                        f"Voc√™ √© um especialista em seguran√ßa da informa√ß√£o e pentest."
                        f"{global_context_prompt}"
                        f"\n\n{verbosity_prompt}\n\n"
                        f"Sua tarefa √© fornecer informa√ß√µes detalhadas para a vulnerabilidade **'{specific_vulnerability_name}'**,"
                        f"que se enquadra na categoria da OWASP Top 10 (2021) como **'{OWASP_TOP_10_2021[categoria_owasp_codigo]}' ({categoria_owasp_codigo})**."
                        f"Considere o seguinte contexto adicional livre: '{st.session_state.owasp_text_context_input}'."
                        f"\n\nPor favor, inclua os seguintes t√≥picos de forma **concisa, t√©cnica e pr√°tica**, utilizando formato Markdown para t√≠tulos e blocos de c√≥digo:"
                        f"\n\n## 1. Detalhamento da Falha"
                        f"\nExplique a natureza da vulnerabilidade de forma clara e concisa: o que ela √©, como surge e por que √© um problema de seguran√ßa. Foque nos conceitos essenciais e no seu mecanismo, **especificamente para '{specific_vulnerability_name}'**.\n"
                        f"\n\n## 2. Cen√°rio de Exemplo de Explora√ß√£o"
                        f"\nIlustre um cen√°rio de ataque potencial que explora essa vulnerabilidade. Descreva as etapas passo a passo que um atacante poderia seguir para explor√°-la, incluindo o ambiente t√≠pico e as condi√ß√µes necess√°rias para o sucesso do ataque, **aplicado a '{specific_vulnerability_name}'**. N√£o inclua c√≥digo aqui, apenas a l√≥gica.\n"
                        f"\n\n## 3. Severidade e Impacto T√©cnico"
                        f"\nClassifique a severidade desta vulnerabilidade: [Cr√≠tica/Alta/M√©dia/Baixa].\n"
                        f"**Impacto T√©cnico Detalhado:** Descreva as **consequ√™ncias t√©cnicas diretas e espec√≠ficas** da explora√ß√£o desta falha, indo al√©m do gen√©rico. Ex: 'A execu√ß√£o desta SQL Injection pode resultar em exfiltra√ß√£o completa do banco de dados de usu√°rios, comprometimento do servidor web subjacente (se Shell via SQLMap), e bypass de autentica√ß√£o.'\n"
                        f"**CVSSv3.1 Score:** Forne√ßa uma estimativa do score CVSS v3.1 para esta vulnerabilidade e o vetor CVSS. Ex: `7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N)`\n"
                    )

                    if consider_waf_texto:
                         prompt_base += f"\n\n## 4. Dicas de Bypass de WAF"
                         prompt_base += f"\nForne√ßa estrat√©gias, t√©cnicas e exemplos pr√°ticos (se aplic√°vel √† vulnerabilidade) para contornar ou evadir a detec√ß√£o de um Web Application Firewall (WAF) ao tentar explorar esta falha. Inclua exemplos de payloads ou modifica√ß√µes de requisi√ß√µes que podem ajudar a testar o presen√ßa ou bypass do WAF."
                         solution_section_num = 5
                         benefits_risks_section_num = 6
                    else:
                         solution_section_num = 4
                         benefits_risks_section_num = 5

                    prompt_base += (
                        f"\n\n## {solution_section_num}. Detalhamento da Solu√ß√£o"
                        f"\nDescreva as **a√ß√µes de corre√ß√£o concretas, detalhadas e com exemplos t√©cnicos se poss√≠vel**. Evite generaliza√ß√µes."
                        f"**Se o 'Contexto Adicional Livre' cont√©m detalhes de explora√ß√£o ou trechos de c√≥digo, baseie suas dicas de solu√ß√£o diretamente nesse c√≥digo ou nos princ√≠pios de explora√ß√£o descritos, oferecendo corre√ß√µes coesas e precisas para aquele cen√°rio espec√≠fico.**"
                        f"Seja espec√≠fico. Ex: 'Para mitigar SQL Injection, implemente Prepared Statements ou ORM's seguros (com exemplo de c√≥digo em Python/Java), use valida√ß√£o de input rigorosa (whitelist) no backend, e aplique o princ√≠pio do menor privil√©gio ao usu√°rio do banco de dados.'\n"
                        f"\n\n## {benefits_risks_section_num}. Benef√≠cios e Riscos da Corre√ß√£o"
                        f"\nQuais s√£o os benef√≠cios de implementar a solu√ß√£o e os poss√≠veis riscos ou impactos colaterais da sua aplica√ß√£o?"
                        f"\n\nSeu objetivo √© ser direto, √∫til e focado em a√ß√µes e informa√ß√µes completas para um pentester, como um resumo para um relat√≥rio de pentest."
                    )

                    analysis_result = obter_resposta_llm(llm_model_text, [prompt_base])

                    if analysis_result:
                        st.session_state.owasp_text_analysis_result = analysis_result
                        logging.info("OWASP Vulnerability Details: An√°lise de texto conclu√≠da com sucesso.")

                        if not st.session_state.get('modo_rascunho', False):
                            try:
                                resumo_para_db = f"Consulta sobre a vulnerabilidade: '{st.session_state.owasp_text_input_falha}'"
                                database.salvar_analise(
                                    projeto_id=st.session_state.projeto_ativo_id,
                                    tipo_analise="OWASP Vulnerability Details",
                                    resumo_input=resumo_para_db,
                                    resultado_completo=analysis_result
                                )
                                st.toast("Consulta salva com sucesso no projeto!", icon="üíæ")
                            except Exception as e:
                                st.error(f"Houve um erro ao salvar a consulta no banco de dados: {e}")
                        else:
                            st.toast("Modo Rascunho: Resultado n√£o salvo.", icon="‚úèÔ∏è")
                    else:
                        st.session_state.owasp_text_analysis_result = "N√£o foi poss√≠vel obter uma resposta do Gemini. Tente novamente."

    if st.session_state.owasp_text_analysis_result:
        st.subheader("Resultados da An√°lise por Texto")
        st.markdown(st.session_state.owasp_text_analysis_result)
        
        # --- IN√çCIO DA CORRE√á√ÉO: BOT√ïES DE FEEDBACK RESTAURADOS ---
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="owasp_text_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback OWASP Vulnerability Details: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="owasp_text_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback OWASP Vulnerability Details: Precisa de Melhoria.")
        # --- FIM DA CORRE√á√ÉO ---

def http_request_analysis_page(llm_model_vision, llm_model_text):
    st.header("Deep HTTP Insight üì°")
    st.markdown("""
    Selecione o tipo de conte√∫do para an√°lise. Voc√™ pode colar:
    - **Requisi√ß√£o HTTP RAW:** Analisa requisi√ß√µes HTTP completas em busca de falhas OWASP.
    - **Headers de Resposta HTTP:** Analisa cabe√ßalhos de resposta para misconfigurations e exposi√ß√£o de informa√ß√µes.
    - **Configura√ß√£o de Servidor:** Analisa trechos de configura√ß√£o de servidores (Apache, Nginx, IIS) para hardening.
    """)

    # Inicializar vari√°veis de sess√£o
    if 'http_analysis_type' not in st.session_state:
        st.session_state.http_analysis_type = "Requisi√ß√£o HTTP RAW"
    if 'http_request_input_url' not in st.session_state:
        st.session_state.http_request_input_url = ""
    if 'http_analysis_content' not in st.session_state:
        st.session_state.http_analysis_content = ""
    if 'http_analysis_result' not in st.session_state:
        st.session_state.http_analysis_result = ""
    if 'http_analysis_summary' not in st.session_state:
        st.session_state.http_analysis_summary = None
    if 'http_context_free_input' not in st.session_state:
        st.session_state.http_context_free_input = ""

    logging.info("P√°gina Deep HTTP Insight acessada.")

    # Resetar campos se necess√°rio
    def reset_http_analysis():
        st.session_state.http_analysis_type = "Requisi√ß√£o HTTP RAW"
        st.session_state.http_request_input_url = ""
        st.session_state.http_analysis_content = ""
        st.session_state.http_analysis_result = ""
        st.session_state.http_analysis_summary = None
        st.session_state.http_context_free_input = ""
        logging.info("Deep HTTP Insight: Reset de campos.")
        st.rerun()

    # Bot√£o para limpar e fazer nova consulta
    if st.button("Limpar e Fazer Nova Consulta", key="reset_http_analysis_button"):
        reset_http_analysis()

    # Selecionar tipo de an√°lise
    analysis_type_options = [
        "Requisi√ß√£o HTTP RAW",
        "Headers de Resposta HTTP",
        "Configura√ß√£o de Servidor (Apache/Nginx/IIS)"
    ]
    st.session_state.http_analysis_type = st.radio(
        "Tipo de An√°lise:",
        options=analysis_type_options,
        key="http_analysis_type_radio"
    )

    # URL alvo (apenas para Requisi√ß√£o HTTP RAW)
    if st.session_state.http_analysis_type == "Requisi√ß√£o HTTP RAW":
        st.session_state.http_request_input_url = st.text_input(
            "URL Alvo (Target):",
            value=st.session_state.http_request_input_url,
            placeholder="Exemplo: https://example.com/path "
        )
        if not st.session_state.http_request_input_url:
            st.error("Por favor, forne√ßa a URL Alvo para a Requisi√ß√£o HTTP RAW.")
            logging.warning("Deep HTTP Insight: An√°lise de Requisi√ß√µes HTTP abortada, URL Alvo vazia.")
            return

    # Conte√∫do para an√°lise
    content_placeholder = (
        "- Para **Requisi√ß√£o HTTP RAW**: Cole aqui a requisi√ß√£o completa.\n"
        "- Para **Headers de Resposta HTTP**: Cole apenas os headers.\n"
        "- Para **Configura√ß√£o de Servidor**: Cole o trecho de configura√ß√£o."
    )
    st.session_state.http_analysis_content = st.text_area(
        f"Cole o conte√∫do para an√°lise aqui ({st.session_state.http_analysis_type}):",
        value=st.session_state.http_analysis_content,
        placeholder=content_placeholder,
        height=300,
        key="http_config_input_area"
    )
    if not st.session_state.http_analysis_content.strip():
        st.error("Por favor, cole o conte√∫do para an√°lise.")
        logging.warning("Deep HTTP Insight: An√°lise abortada, conte√∫do vazio.")
        return

    # Contexto adicional livre
    st.session_state.http_context_free_input = st.text_area(
        "Contexto Adicional Livre (opcional, para detalhes de explora√ß√£o ou trechos de c√≥digo):",
        value=st.session_state.http_context_free_input,
        placeholder=(
            "Ex: 'A explora√ß√£o foi feita injetando `'; OR 1=1--` no par√¢metro `id` da URL.', "
            "'Trecho de c√≥digo: `user_id = request.args.get('id')`'"
        ),
        height=100,
        key="http_context_free_input_area"
    )

    # Bot√£o para analisar
    if st.button("Analisar Conte√∫do", key="analyze_http_content_button"):
        with st.spinner(f"Analisando {st.session_state.http_analysis_type} com LLM..."):
            # Preparar o prompt baseado no tipo de an√°lise
            global_context_prompt = get_global_context_prompt()
            escaped_http_context_free_input = st.session_state.http_context_free_input.replace('{', '{{').replace('}', '}}')

            if st.session_state.http_analysis_type == "Requisi√ß√£o HTTP RAW":
                prompt_intro_context = (
                    "Voc√™ √© um especialista em seguran√ßa da informa√ß√£o e pentest." +
                    global_context_prompt +
                    f"Analise a requisi√ß√£o HTTP RAW fornecida e a URL alvo '{st.session_state.http_request_input_url}'. Identifique **TODAS as poss√≠veis falhas de seguran√ßa OWASP Top 10 (2021) e outras vulnerabilidades relevantes aplic√°veis**, sendo extremamente detalhado e preciso na an√°lise de cada parte da requisi√ß√£o. "
                )
                code_lang = "http"

                # Parsear a requisi√ß√£o HTTP RAW
                parsed_req = parse_raw_http_request(st.session_state.http_analysis_content)
                prompt_content_for_llm = (
                    f"URL Alvo: {st.session_state.http_request_input_url}\n"
                    f"M√©todo: {parsed_req['method']}\n"
                    f"Caminho: {parsed_req['path']}\n"
                    f"Headers:\n{json.dumps(parsed_req['headers'], indent=2).replace('{', '{{').replace('}', '}}')}\n"
                    f"Corpo:\n{parsed_req['body'].replace('{', '{{').replace('}', '}}')}\n"
                    f"Requisi√ß√£o RAW Original:\n{st.session_state.http_analysis_content.replace('{', '{{').replace('}', '}}')}"
                )

            elif st.session_state.http_analysis_type == "Headers de Resposta HTTP":
                prompt_intro_context = (
                    "Voc√™ √© um especialista em seguran√ßa web e an√°lise de headers HTTP." +
                    global_context_prompt +
                    "Analise os seguintes headers de resposta HTTP. Identifique misconfigurations de seguran√ßa, exposi√ß√£o de informa√ß√µes sens√≠veis e a falta de headers de seguran√ßa importantes. Priorize a descri√ß√£o do achado e o exemplo de impacto."
                )
                code_lang = "http"
                prompt_content_for_llm = st.session_state.http_analysis_content.replace('{', '{{').replace('}', '}}')

            elif st.session_state.http_analysis_type == "Configura√ß√£o de Servidor (Apache/Nginx/IIS)":
                prompt_intro_context = (
                    "Voc√™ √© um especialista em hardening de servidores web (Apache, Nginx, IIS) e pentest." +
                    global_context_prompt +
                    "\n\nAnalise o seguinte trecho de configura√ß√£o de servidor. Identifique misconfigurations de seguran√ßa (OWASP A05), diret√≥rios expostos, e outras vulnerabilidades. Priorize a descri√ß√£o do achado e o exemplo de impacto."
                )
                code_lang = "plaintext"
                prompt_content_for_llm = st.session_state.http_analysis_content.replace('{', '{{').replace('}', '}}')

            # Montar o prompt completo
            full_prompt = (
                prompt_intro_context +
                f"\n\n**RESUMO:** Forne√ßa um resumo quantitativo na PRIMEIRA LINHA da sua resposta, no formato exato: `Total de Achados: X | Cr√≠ticos: Y | Altos: Z | M√©dios: W | Baixos: V` (substitua X,Y,Z,W,V pelos n√∫meros correspondentes). Se n√£o houver achados, use 0.\n\n"
                f"**Conte√∫do para an√°lise:**\n"
                f"```{code_lang}\n{prompt_content_for_llm}\n```\n\n"
                f"Para cada **achado de seguran√ßa (vulnerabilidade ou misconfiguration)** identificado, apresente os seguintes t√≥picos de forma separada e concisa, utilizando Markdown. **Comece cada achado com um cabe√ßalho `###`:**\n\n"
                f"### [Tipo de Achado] (Ex: Header de Seguran√ßa Ausente, Vers√£o do Servidor Exposta)\n"
                f"**Categoria OWASP (se aplic√°vel):** [Ex: A05: Security Misconfiguration]. Se n√£o OWASP, indique 'Exposi√ß√£o de Informa√ß√£o' ou 'Melhoria de Hardening'.\n"
                f"**Severidade/Risco:** [Cr√≠tica/Alta/M√©dia/Baixa/Informativo - explique o impacto deste achado espec√≠fico]\n"
                f"**Detalhes no Conte√∫do:** Explique onde no conte√∫do fornecido a falha foi observada. Cite o trecho relevante da requisi√ß√£o/configura√ß√£o. Seja preciso na correla√ß√£o.\n"
                f"**Exemplo de Explora√ß√£o:** Descreva o risco e como um atacante poderia se beneficiar desta configura√ß√£o/vulnerabilidade. Forne√ßa um comando simples, um payload ou uma explica√ß√£o de como testar/explorar. **Se o 'Contexto Adicional Livre' (fornecido pelo usu√°rio) cont√©m detalhes de um PoC ou trechos de c√≥digo de explora√ß√£o, baseie seu exemplo diretamente nele, incluindo o c√≥digo/comando relevante em um bloco de c√≥digo Markdown (` ```{code_lang} ` ou ` ```bash ` ou ` ```http `).** Se o contexto livre for irrelevante ou n√£o tiver PoC, forne√ßa um exemplo gen√©rico e aplic√°vel. N√£o se preocupe com \"Recomenda√ß√£o/Mitiga√ß√£o\" ou \"Ferramentas Sugeridas\" separadamente.\n"
                f"--- (Fim do Achado) ---"  # Separador para o pr√≥ximo achado
            )

            # Obter resposta do LLM
            analysis_result = obter_resposta_llm(llm_model_text, [full_prompt])
            if analysis_result:
                st.session_state.http_analysis_result = analysis_result
                logging.info("Deep HTTP Insight: An√°lise conclu√≠da com sucesso.")
            else:
                st.session_state.http_analysis_result = "N√£o foi poss√≠vel obter uma resposta do LLM. Tente novamente."
                logging.error("Deep HTTP Insight: Falha na obten√ß√£o da resposta do LLM.")

            # Parsear o resumo
            if st.session_state.http_analysis_result:
                summary_match = re.search(
                    r'Total de Achados:\s*(\d+)\s*\|\s*Cr√≠ticos:\s*(\d+)\s*\|\s*Altos:\s*(\d+)\s*\|\s*M√©dios:\s*(\d+)\s*\|\s*Baixos:\s*(\d+)',
                    st.session_state.http_analysis_result
                )
                if summary_match:
                    total, criticos, altos, medios, baixos = map(int, summary_match.groups())
                    st.session_state.http_analysis_summary = {
                        "Total": total,
                        "Cr√≠ticas": criticos,
                        "Altas": altos,
                        "M√©dios": medios,
                        "Baixos": baixos
                    }
                else:
                    st.session_state.http_analysis_summary = {"Total": 0, "Cr√≠ticas": 0, "Altas": 0, "M√©dios": 0, "Baixos": 0}
                    logging.warning("Deep HTTP Insight: Resumo de vulnerabilidades n√£o encontrado na resposta do LLM.")

    # Exibir resultados
    if st.session_state.http_analysis_result:
        st.subheader("Resultados da An√°lise de Seguran√ßa")

        # Exibir m√©tricas
        if st.session_state.http_analysis_summary:
            cols = st.columns(5)
            cols[0].metric("Total", st.session_state.http_analysis_summary.get("Total", 0))
            cols[1].metric("Cr√≠ticos", st.session_state.http_analysis_summary.get("Cr√≠ticas", 0))
            cols[2].metric("Altos", st.session_state.http_analysis_summary.get("Altas", 0))
            cols[3].metric("M√©dios", st.session_state.http_analysis_summary.get("M√©dios", 0))
            cols[4].metric("Baixos", st.session_state.http_analysis_summary.get("Baixos", 0))

        # Exibir detalhes das vulnerabilidades
        st.markdown(st.session_state.http_analysis_result)

        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="http_analysis_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Deep HTTP Insight: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="http_analysis_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Deep HTTP Insight: Precisa de Melhoria.")

    logging.info("P√°gina Deep HTTP Insight finalizada.")

def pentest_lab_page(llm_model_vision, llm_model_text):
    st.header("Pentest Lab: Seu Laborat√≥rio de Vulnerabilidades üß™")
    st.markdown("""
        Selecione uma vulnerabilidade e o HuntIA ir√° gerar um mini-laborat√≥rio HTML b√°sico (PoC em HTML) para que voc√™ possa testar a falha diretamente no seu navegador.
        Tambi√©n fornecer√° dicas de como explorar e o payload/comando para o teste.
        **AVISO: Este laborat√≥rio √© para fins educacionais e de teste. N√£o execute payloads em sites reais.**
    """)
    logging.info("P√°gina Pentest Lab acessada.")

    # Initialize session state variables for this page
    if 'lab_vulnerability_selected' not in st.session_state:
        st.session_state.lab_vulnerability_selected = None
    if 'lab_html_poc' not in st.session_state:
        st.session_state.lab_html_poc = ""
    if 'lab_explanation' not in st.session_state:
        st.session_state.lab_explanation = ""
    if 'lab_payload_example' not in st.session_state:
        st.session_state.lab_payload_example = ""

    def reset_pentest_lab():
        st.session_state.lab_vulnerability_selected = None
        st.session_state.lab_html_poc = ""
        st.session_state.lab_explanation = ""
        st.session_state.lab_payload_example = ""
        logging.info("Pentest Lab: Reset de campos.")
        st.rerun()

    if st.button("Limpar Laborat√≥rio", key="reset_lab_button"):
        reset_pentest_lab()

    vulnerability_options = ["Escolha uma vulnerabilidade"] + sorted(OWASP_SUBCATEGORIES["A03"])

    selected_vuln = st.selectbox(
        "Selecione a vulnerabilidade para o laborat√≥rio:",
        options=vulnerability_options,
        index=0,
        key="lab_vuln_select"
    )
    st.session_state.lab_vulnerability_selected = selected_vuln if selected_vuln != "Escolha uma vulnerabilidade" else None

    if st.button("Gerar Laborat√≥rio", key="generate_lab_button"):
        if not st.session_state.lab_vulnerability_selected:
            st.error("Por favor, selecione uma vulnerabilidade para gerar o laborat√≥rio.")
            logging.warning("Pentest Lab: Gera√ß√£o abortada, nenhuma vulnerabilidade selecionada.")
            return
        else:
            with st.spinner(f"Gerando laborat√≥rio para {st.session_state.lab_vulnerability_selected}..."):
                logging.info(f"Pentest Lab: Gerando laborat√≥rio para {st.session_state.lab_vulnerability_selected}.")

                # Contexto global √© injetado aqui
                global_context_prompt = get_global_context_prompt()

                lab_prompt = (
                    f"Voc√™ √© um especialista em pentest e educador."
                    f"{global_context_prompt}" # INJETANDO CONTEXTO GLOBAL
                    f"\n\nSua tarefa √© criar um mini-laborat√≥rio HTML simples e um payload para demonstrar a vulnerabilidade '{st.session_state.lab_vulnerability_selected}'.\n"
                    f"\nForne√ßa as informa√ß√µes nos seguintes t√≥picos:\n\n"
                    f"## 1. Descri√ß√£o da Vulnerabilidade e Dicas de Explora√ß√£o\n"
                    f"Uma breve explica√ß√£o do que √© a vulnerabilidade, como ela funciona e dicas pr√°ticas de como tentar explor√°-la.\n\n"
                    f"## 2. Mini-Laborat√≥rio HTML (PoC HTML)\n"
                    f"Forne√ßa um **c√≥digo HTML COMPLETO e M√çNIMO** (com tags `<html>`, `<head>`, `<body>`) que simule um cen√°rio vulner√°vel a **{st.session_state.lab_vulnerability_selected}**.\n"
                    f"Este HTML deve ser funcional e auto-contido. O foco √© na vulnerabilidade, n√£o no design.\n"
                    f"Encapsule o HTML completo em um bloco de c√≥digo Markdown com a linguagem `html` (` ```html `).\n\n"
                    f"## 3. Exemplo de Payload/Comando para Teste\n"
                    f"Forne√ßa o payload ou comando espec√≠fico que o usu√°rio injetaria ou usaria neste HTML para provar a vulnerabilidade. Encapsule em um bloco de c√≥digo Markdown com la linguagem apropriada (ex: ` ```js `, ` ```sql `, ` ```bash `).\n"
                    f"Este payload deve ser adaptado para o HTML gerado no PoC HTML.\n"
                    f"\nSeja did√°tico e direto. O objetivo √© que o usu√°rio possa copiar e colar o HTML e o payload para testar."
                )

                lab_generation_raw = obter_resposta_llm(llm_model_text, [lab_prompt])

                if lab_generation_raw:
                    st.session_state.lab_explanation = lab_generation_raw

                    html_start = lab_generation_raw.find("```html")
                    html_end = lab_generation_raw.find("```", html_start + len("```html"))

                    payload_start_marker = "```"

                    if html_start != -1 and html_end != -1:
                        payload_start = lab_generation_raw.find(payload_start_marker, html_end + 1)
                    else:
                        payload_start = lab_generation_raw.find(payload_start_marker)

                    payload_end = -1
                    if payload_start != -1:
                        payload_end = lab_generation_raw.find(payload_start_marker, payload_start + len(payload_start_marker))
                        if payload_end == payload_start:
                            payload_end = -1

                    if html_start != -1 and html_end != -1:
                        st.session_state.lab_html_poc = lab_generation_raw[html_start + len("```html") : html_end].strip()
                    else:
                        st.session_state.lab_html_poc = "N√£o foi poss√≠vel extrair o HTML do laborat√≥rio. Verifique a resposta do LLM."
                        logging.warning("Pentest Lab: HTML n√£o extra√≠do da resposta do LLM.")

                    if payload_start != -1 and payload_end != -1:
                        payload_content = lab_generation_raw[payload_start + len(payload_start_marker) : payload_end].strip()
                        if '\n' in payload_content and payload_content.splitlines()[0].strip().isalpha():
                            st.session_state.lab_payload_example = '\n'.join(payload_content.splitlines()[1:])
                        else:
                            st.session_state.lab_payload_example = payload_content
                        logging.info("Pentest Lab: Laborat√≥rio gerado com sucesso.")
                    else:
                        st.session_state.lab_payload_example = "N√£o foi poss√≠vel extrair o exemplo de payload. Verifique a resposta do LLM."
                        logging.warning("Pentest Lab: Payload n√£o extra√≠do da resposta do LLM.")
                else:
                    st.session_state.lab_explanation = "N√£o foi poss√≠vel gerar o laborat√≥rio para a vulnerabilidade selecionada."
                    st.session_state.lab_html_poc = ""
                    st.session_state.lab_payload_example = ""
                    logging.error("Pentest Lab: Falha na gera√ß√£o do laborat√≥rio pelo LLM.")

    if st.session_state.lab_html_poc or st.session_state.lab_explanation:
        st.subheader("Resultados do Laborat√≥rio")

        st.markdown(st.session_state.lab_explanation)

        if st.session_state.lab_html_poc:
            st.markdown("#### Mini-Laborat√≥rio HTML (Copie e Cole em um arquivo .html e abra no navegador)")
            st.code(st.session_state.lab_html_poc, language="html")

            st.markdown("---")
            st.markdown("#### Teste o Laborat√≥rio Aqui (Visualiza√ß√£o Direta)")
            st.warning("AVISO: Esta visualiza√ß√£o direta √© para conveni√™ncia. Para um teste real e isolado, **salve o HTML em um arquivo .html e abra-o diretamente no seu navegador**.")
            components.html(st.session_state.lab_html_poc, height=300, scrolling=True)
            st.markdown("---")

        if st.session_state.lab_payload_example: # Usando lab_payload_example pois √© o que est√° em session_state para esta p√°gina
            st.markdown("#### Exemplo de Payload/Comando para Teste")
            payload_lang = "plaintext"
            first_line = st.session_state.lab_payload_example.splitlines()[0].strip() if st.session_state.lab_payload_example else ""

            if "alert(" in st.session_state.lab_payload_example.lower() or "document.write" in st.session_state.lab_payload_example.lower():
                payload_lang = "js"
            elif "SELECT " in st.session_state.lab_payload_example.upper() and "FROM " in st.session_state.lab_payload_example.upper():
                payload_lang = "sql"
            elif "http" in first_line.lower() and ("post" in first_line.lower() or "get" in first_line.lower()):
                payload_lang = "http"
            elif "curl " in first_line.lower() or "bash" in first_line.lower():
                payload_lang = "bash"
            elif "python" in first_line.lower() or "import" in st.session_state.lab_payload_example.lower():
                payload_lang = "python"

            st.code(st.session_state.lab_payload_example, language=payload_lang)
        
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="pentest_lab_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Pentest Lab: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="pentest_lab_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Pentest Lab: Precisa de Melhoria.")

def poc_generator_html_page(llm_model_vision, llm_model_text):
    st.header("PoC Generator (HTML): Crie Provas de Conceito em HTML üìÑ")
    st.markdown("""
        Gere c√≥digos HTML de Prova de Conceito para testar vulnerabilidades espec√≠ficas no navegador.
        Perfeito para demonstrar falhas como CSRF, Clickjacking, CORS, e XSS baseados em HTML.
    """)
    logging.info("P√°gina PoC Generator (HTML) acessada.")

    # --- In√≠cio do Bloco Universal de Verifica√ß√£o ---
    if not st.session_state.get('projeto_ativo_id') and not st.session_state.get('modo_rascunho'):
        st.error("Por favor, selecione um projeto ou ative o 'Modo Rascunho' na p√°gina de Configura√ß√µes.")
        st.stop()
    
    if st.session_state.get('modo_rascunho'):
        st.info("Voc√™ est√° no Modo Rascunho. Esta PoC n√£o ser√° salva. ‚úèÔ∏è")
    else:
        st.success(f"Gerando PoC para o projeto: **{st.session_state.projeto_ativo_nome}**")
    st.markdown("---")
    # --- Fim do Bloco Universal ---

    # Initialize session state variables for this page
    if 'poc_gen_vulnerability_input' not in st.session_state:
        st.session_state.poc_gen_vulnerability_input = ""
    if 'poc_gen_context_input' not in st.session_state:
        st.session_state.poc_gen_context_input = ""
    if 'poc_gen_html_output' not in st.session_state:
        st.session_state.poc_gen_html_output = ""
    if 'poc_gen_instructions' not in st.session_state:
        st.session_state.poc_gen_instructions = ""
    if 'poc_gen_payload_example' not in st.session_state:
        st.session_state.poc_gen_payload_example = ""

    def reset_poc_generator():
        st.session_state.poc_gen_vulnerability_input = ""
        st.session_state.poc_gen_context_input = ""
        st.session_state.poc_gen_html_output = ""
        st.session_state.poc_gen_instructions = ""
        st.session_state.poc_gen_payload_example = ""
        logging.info("PoC Generator (HTML): Reset de campos.")
        st.rerun()

    if st.button("Limpar Gerador", key="reset_poc_gen_button"):
        reset_poc_generator()

    vulnerability_input = st.text_input(
        "Digite a vulnerabilidade para gerar a PoC HTML (Ex: CSRF, Clickjacking, CORS, XSS):",
        value=st.session_state.poc_gen_vulnerability_input,
        placeholder="Ex: CSRF, Clickjacking, CORS, XSS refletido",
        key="poc_gen_vuln_input"
    )
    st.session_state.poc_gen_vulnerability_input = vulnerability_input.strip()

    context_input = st.text_area(
        "Contexto Adicional (URL alvo, par√¢metros, m√©todo, etc.):",
        value=st.session_state.poc_gen_context_input,
        placeholder="Ex: 'URL: https://exemplo.com/transferencia, Par√¢metros: conta=123&valor=100, M√©todo: POST'",
        height=150,
        key="poc_gen_context_input_area"
    )
    st.session_state.poc_gen_context_input = context_input.strip()

    if st.button("Gerar PoC HTML", key="generate_poc_html_button"):
        if not st.session_state.poc_gen_vulnerability_input:
            st.error("Por favor, digite a vulnerabilidade para gerar a PoC.")
            logging.warning("PoC Generator (HTML): Gera√ß√£o abortada, vulnerabilidade vazia.")
            return
        else:
            with st.spinner(f"Gerando PoC HTML para {st.session_state.poc_gen_vulnerability_input}..."):
                logging.info(f"PoC Generator (HTML): Gerando PoC para {st.session_state.poc_gen_vulnerability_input}.")

                # Injetando Contexto e Verbosidade
                global_context_prompt = get_global_context_prompt()
                verbosity_prompt = get_verbosity_prompt()

                poc_prompt = (
                    f"Voc√™ √© um especialista em pentest e possui autoriza√ß√£o para realizar testes de seguran√ßa. "
                    f"{global_context_prompt}"
                    f"\n\n{verbosity_prompt}\n\n"
                    f"Sua tarefa √© gerar uma Prova de Conceito (PoC) em HTML funcional e um payload/instru√ß√µes para demonstrar a vulnerabilidade '{st.session_state.poc_gen_vulnerability_input}'.\n"
                    f"**Contexto:** {st.session_state.poc_gen_context_input if st.session_state.poc_gen_context_input else 'Nenhum contexto adicional fornecido.'}\n\n"
                    f"Forne√ßa as informa√ß√µes nos seguintes t√≥picos:\n\n"
                    f"## 1. Detalhes da Vulnerabilidade e Como Funciona\n"
                    f"Uma breve explica√ß√£o do que √© a vulnerabilidade, como ela funciona e como a PoC a demonstra, respeitando o n√≠vel de verbosidade solicitado.\n\n"
                    f"## 2. C√≥digo HTML da PoC (Completo e M√≠nimo)\n"
                    f"Forne√ßa um **c√≥digo HTML COMPLETO e M√çNIMO** (com tags `<html>`, `<head>`, `<body>`) que simule um cen√°rio vulner√°vel a **{st.session_state.poc_gen_vulnerability_input}**.\n"
                    f"Este HTML deve ser funcional e auto-contido. O foco √© na vulnerabilidade, n√£o no design.\n"
                    f"Encapsule o HTML completo em um bloco de c√≥digo Markdown com a linguagem `html` (` ```html).\n\n"
                    f"## 3. Instru√ß√µes de Uso e Payload (se aplic√°vel)\n"
                    f"Descreva como o usu√°rio deve usar este HTML para testar a PoC. Se for necess√°rio um payload ou comando espec√≠fico (ex: um script XSS, uma URL modificada para Clickjacking), forne√ßa-o explicitamente e encapsule-o em um bloco de c√≥digo Markdown com la linguagem apropriada (ex: ` ```js `, ` ```sql `, ` ```bash `).\n"
                    f"\nSeja direto, pr√°tico e did√°tico. O objetivo √© que o usu√°rio (um pentester autorizado) possa copiar e colar o HTML e as instru√ß√µes para testar a falha em um ambiente de teste autorizado."
                )

                poc_generation_raw = obter_resposta_llm(llm_model_text, [poc_prompt])

                if poc_generation_raw:
                    st.session_state.poc_gen_instructions = poc_generation_raw

                    # Sua l√≥gica de parsing original (mantida)
                    html_start = poc_generation_raw.find("```html")
                    html_end = poc_generation_raw.find("```", html_start + len("```html"))
                    payload_start_marker = "```"
                    if html_start != -1 and html_end != -1:
                        payload_start = poc_generation_raw.find(payload_start_marker, html_end + 1)
                    else:
                        payload_start = poc_generation_raw.find(payload_start_marker)
                    payload_end = -1
                    if payload_start != -1:
                        payload_end = poc_generation_raw.find(payload_start_marker, payload_start + len(payload_start_marker))
                        if payload_end == payload_start:
                            payload_end = -1
                    if html_start != -1 and html_end != -1:
                        st.session_state.poc_gen_html_output = poc_generation_raw[html_start + len("```html") : html_end].strip()
                    else:
                        st.session_state.poc_gen_html_output = "N√£o foi poss√≠vel extrair o HTML do PoC. Verifique a resposta do LLM."
                        logging.warning("PoC Generator (HTML): HTML n√£o extra√≠do da resposta do LLM.")
                    if payload_start != -1 and payload_end != -1:
                        payload_content = poc_generation_raw[payload_start + len(payload_start_marker) : payload_end].strip()
                        if '\n' in payload_content and payload_content.splitlines()[0].strip().isalpha():
                            st.session_state.poc_gen_payload_example = '\n'.join(payload_content.splitlines()[1:])
                        else:
                            st.session_state.poc_gen_payload_example = payload_content
                        logging.info("PoC Generator (HTML): PoC gerado com sucesso.")
                    else:
                        st.session_state.poc_gen_payload_example = "N√£o foi poss√≠vel extrair o exemplo de payload. Verifique a resposta do LLM."
                        logging.warning("PoC Generator (HTML): Payload n√£o extra√≠do da resposta do LLM.")

                    # In√≠cio do Padr√£o Universal de Salvamento
                    if not st.session_state.get('modo_rascunho', False):
                        try:
                            resumo_para_db = f"PoC HTML Gerada para: '{st.session_state.poc_gen_vulnerability_input}' com contexto: '{st.session_state.poc_gen_context_input}'"
                            database.salvar_analise(
                                projeto_id=st.session_state.projeto_ativo_id,
                                tipo_analise="PoC Generator (HTML)",
                                resumo_input=resumo_para_db,
                                resultado_completo=poc_generation_raw
                            )
                            st.toast("PoC HTML salva com sucesso no projeto!", icon="üíæ")
                        except Exception as e:
                            st.error(f"Houve um erro ao salvar a PoC no banco de dados: {e}")
                    else:
                        st.toast("Modo Rascunho: Resultado n√£o salvo.", icon="‚úèÔ∏è")
                    # Fim do Padr√£o Universal de Salvamento
                else:
                    st.session_state.poc_gen_instructions = "N√£o foi poss√≠vel gerar a PoC HTML para a vulnerabilidade selecionada."
                    st.session_state.poc_gen_html_output = ""
                    st.session_state.poc_gen_payload_example = ""
                    logging.error("PoC Generator (HTML): Falha na gera√ß√£o da PoC pelo LLM.")

    if st.session_state.poc_gen_html_output or st.session_state.poc_gen_instructions:
        st.subheader("Results da PoC HTML")

        st.markdown(st.session_state.poc_gen_instructions)

        if st.session_state.poc_gen_html_output:
            st.markdown("#### Mini-Laborat√≥rio HTML (Copie e Cole em um arquivo .html e abra no navegador)")
            st.code(st.session_state.poc_gen_html_output, language="html")

            st.markdown("---")
            st.markdown("#### Teste o Laborat√≥rio Aqui (Visualiza√ß√£o Direta)")
            st.warning("AVISO: Esta visualiza√ß√£o direta √© para conveni√™ncia. Para um teste real e isolado, **salve o HTML em um arquivo .html e abra-o diretamente no seu navegador**.")
            components.html(st.session_state.poc_gen_html_output, height=300, scrolling=True)
            st.markdown("---")

        if st.session_state.poc_gen_payload_example:
            st.markdown("#### Exemplo de Payload/Comando para Teste")
            payload_lang = "plaintext"
            first_line = st.session_state.poc_gen_payload_example.splitlines()[0].strip() if st.session_state.poc_gen_payload_example else ""

            if "alert(" in st.session_state.poc_gen_payload_example.lower() or "document.write" in st.session_state.poc_gen_payload_example.lower():
                payload_lang = "js"
            elif "SELECT " in st.session_state.poc_gen_payload_example.upper() and "FROM " in st.session_state.poc_gen_payload_example.upper():
                payload_lang = "sql"
            elif "http" in first_line.lower() and ("post" in first_line.lower() or "get" in first_line.lower()):
                payload_lang = "http"
            elif "curl " in first_line.lower() or "bash" in first_line.lower():
                payload_lang = "bash"
            elif "python" in first_line.lower() or "import" in st.session_state.poc_gen_payload_example.lower():
                payload_lang = "python"

            st.code(st.session_state.poc_gen_payload_example, language=payload_lang)
        
        # Feedback Buttons (mantidos)
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="poc_gen_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback PoC Generator (HTML): √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="poc_gen_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback PoC Generator (HTML): Precisa de Melhoria.")

def static_code_analyzer_page(llm_model_vision, llm_model_text):
    st.header("Static Code Analyzer (Avan√ßado para JS/RAW) üë®‚Äçüíª")
    st.markdown("""
        Cole um trecho de c√≥digo ou o RAW de uma resposta HTTP contendo JavaScript.
        O HuntIA ir√° identificar **vulnerabilidades (OWASP Top 10), padr√µes de exposi√ß√£o de informa√ß√µes sens√≠veis (chaves, IPs, tokens, credenciais hardcoded)** e sugerir corre√ß√µes e Provas de Conceito.
        **Especialmente otimizado para an√°lise de arquivos JavaScript e conte√∫do HTTP RAW.**
        **AVISO:** Esta √© uma an√°lise de *primeira linha* e n√£o substitui um SAST completo.
    """)
    logging.info("P√°gina Static Code Analyzer acessada.")

    if 'code_input_content' not in st.session_state:
        st.session_state.code_input_content = ""
    if 'code_analysis_result' not in st.session_state:
        st.session_state.code_analysis_result = ""
    if 'code_language_selected' not in st.session_state:
        st.session_state.code_language_selected = "JavaScript" # Padr√£o para JS
    if 'input_type_selected' not in st.session_state:
        st.session_state.input_type_selected = "C√≥digo JavaScript Direto" # Novo estado para tipo de input

    def reset_code_analyzer():
        st.session_state.code_input_content = ""
        st.session_state.code_analysis_result = ""
        st.session_state.code_language_selected = "JavaScript"
        st.session_state.input_type_selected = "C√≥digo JavaScript Direto"
        logging.info("Static Code Analyzer: Reset de campos.")
        st.rerun()

    if st.button("Limpar An√°lise de C√≥digo", key="reset_code_analysis_button"):
        reset_code_analyzer()

    input_type = st.radio(
        "Tipo de Conte√∫do para An√°lise:",
        ("C√≥digo JavaScript Direto", "HTTP RAW (Corpo JavaScript)"),
        key="static_code_input_type_radio",
        index=0 if st.session_state.input_type_selected == "C√≥digo JavaScript Direto" else 1
    )
    st.session_state.input_type_selected = input_type

    code_placeholder = "Cole seu c√≥digo JavaScript aqui. Ex: const apiKey = 'sk-xxxxxxxxxxxxx';\nfetch('/api/data', { headers: { Authorization: token } });"
    if input_type == "HTTP RAW (Corpo JavaScript)":
        code_placeholder = "Cole a requisi√ß√£o/resposta HTTP RAW que contenha JavaScript no corpo (ex: resposta de um arquivo .js).\nEx: HTTP/1.1 200 OK\nContent-Type: application/javascript\n...\n\nconst secretKey = 'mySuperSecret';"

    code_content = st.text_area(
        "Cole o conte√∫do para an√°lise aqui:",
        value=st.session_state.code_input_content,
        placeholder=code_placeholder,
        height=400,
        key="code_input_area"
    )
    st.session_state.code_input_content = code_content.strip()

    # Se o tipo de input for HTTP RAW, tentamos extrair o corpo
    analyzed_content = ""
    effective_language = st.session_state.code_language_selected # Manter para o prompt

    if input_type == "HTTP RAW (Corpo JavaScript)":
        parsed_http = parse_raw_http_request(st.session_state.code_input_content)
        analyzed_content = parsed_http['body']
        if not analyzed_content:
            st.warning("Nenhum corpo de requisi√ß√£o/resposta HTTP RAW com JavaScript detectado. Certifique-se de que o JavaScript esteja no corpo e n√£o apenas em headers.")
            logging.warning("Static Code Analyzer: Nenhum corpo HTTP RAW detectado para an√°lise JS.")
            # Continuar com o conte√∫do bruto se n√£o encontrar corpo, para o LLM tentar de alguma forma
            analyzed_content = st.session_state.code_input_content
        else:
            st.info("Corpo JavaScript extra√≠do do HTTP RAW para an√°lise.")
            logging.info("Static Code Analyzer: Corpo JS extra√≠do de HTTP RAW.")
        effective_language = "JavaScript" # For√ßar JavaScript para an√°lise de RAW
    else:
        analyzed_content = st.session_state.code_input_content
        # Para "C√≥digo JavaScript Direto", o usu√°rio pode ainda querer especificar a linguagem, mas JS √© o foco
        language_options = ["JavaScript", "Python", "Java", "PHP", "Go", "Ruby", "C#", "SQL", "Outra"]
        selected_language = st.selectbox(
            "Linguagem do C√≥digo (se n√£o for JavaScript):",
            options=language_options,
            index=language_options.index(st.session_state.code_language_selected),
            key="code_language_select"
        )
        st.session_state.code_language_selected = selected_language
        effective_language = selected_language

    if st.button("Analisar C√≥digo/Conte√∫do", key="analyze_code_button"):
        if not analyzed_content:
            st.error("Por favor, cole o conte√∫do para an√°lise.")
            logging.warning("Static Code Analyzer: An√°lise abortada, conte√∫do vazio.")
            return
        
        with st.spinner(f"Analisando c√≥digo/conte√∫do ({effective_language}) com LLM..."):
            logging.info(f"Static Code Analyzer: Iniciando an√°lise de c√≥digo/conte√∫do (tipo: {input_type}, linguagem efetiva: {effective_language}).")

            # --- INJETANDO O CONTEXTO GLOBAL ---
            global_context_prompt = get_global_context_prompt()
            # --- FIM INJE√á√ÉO DE CONTEXTO ---

            code_prompt = (
                f"Voc√™ √© um especialista em seguran√ßa de c√≥digo e pentest, com foco em an√°lise est√°tica de c√≥digo e detec√ß√£o de segredos. "
                f"{global_context_prompt}" # INJETANDO CONTEXTO GLOBAL
                f"\n\nAnalise o seguinte trecho de c√≥digo/conte√∫do na linguagem {effective_language}. "
                f"Seu objetivo √© ser EXTREMAMENTE CERTEIRO e identificar **TODAS as potenciais vulnerabilidades de seguran√ßa (baseadas na OWASP Top 10 e outras falhas comuns)** e, crucialmente, **exposi√ß√£o de informa√ß√µes sens√≠veis e segredos**, tais como:\n"
                f"- **Chaves de API, tokens de autentica√ß√£o, chaves secretas (API_KEY, secret_key, token, bearer, password, access_token, refresh_token, client_secret, etc.)**\n"
                f"- **Credenciais hardcoded (usu√°rios e senhas)**\n"
                f"- Endere√ßos IP de servidores, dom√≠nios internos/de desenvolvimento (ex: `192.168.1.1`, `dev.api.internal`, `test.database.com`)\n"
                f"- URLs internas, endpoints de admin ou de debug expostos (ex: `/admin/`, `/debug`, `/.git/`)\n"
                f"- Coment√°rios de desenvolvedores que possam conter informa√ß√µes sens√≠veis (ex: `TODO: remover esta senha`, `FIXME: credenciais hardcoded aqui`, `username: admin / password: 123`)\n"
                f"- Nomes de diret√≥rios ou caminhos de arquivos internos/sens√≠veis (ex: `/var/www/backup`, `/admin/dev_tools`, `C:\\secrets\\config.ini`)\n"
                f"- **String de conex√£o de banco de dados, chaves de criptografia, valores salt, etc.**\n\n"
                f"**Priorize a busca por API keys, tokens e credenciais expostas, especialmente em c√≥digo JavaScript, que √© o foco prim√°rio aqui.**"
                f"\n\n**Conte√∫do para an√°lise:**\n```\n{analyzed_content}\n```\n\n"
                f"Para cada **achado (vulnerabilidade ou informa√ß√£o sens√≠vel)** identificado, apresente de forma concisa e pr√°tica, utilizando Markdown:\n\n"
                f"## [Tipo de Achado (Ex: Chave de API Exposta, Credenciais Hardcoded, Inje√ß√£o XSS em JS)]\n"
                f"**Categoria OWASP (se aplic√°vel):** [Ex: A02: Cryptographic Failures, A05: Security Misconfiguration, A03: Injection]. Se for uma informa√ß√£o sens√≠vel n√£o OWASP, indique 'Exposi√ß√£o de Informa√ß√£o Sens√≠vel'.\n"
                f"**Severidade/Risco:** [Cr√≠tica/Alta/M√©dia/Baixa - explique o impacto direto e o risco real deste achado espec√≠fico, tanto para vulnerabilidades quanto para informa√ß√µes expostas. Seja preciso no impacto.]\n"
                f"**Localiza√ß√£o no Conte√∫do:** Explique onde no conte√∫do a falha/informa√ß√£o foi observada. Inclua o **n√∫mero da linha aproximado** se poss√≠vel. Ex: `Linha 5: A vari√°vel 'apiKey' cont√©m um segredo hardcoded.`\n"
                f"**Trecho de C√≥digo/Conte√∫do Afetado:** Forne√ßa o trecho de c√≥digo exato que cont√©m a falha ou informa√ß√£o sens√≠vel. Encapsule-o em um bloco de c√≥digo Markdown com a linguagem correspondente (ex: ```javascript, ```python). Este trecho deve ser facilmente identific√°vel no conte√∫do original.\n\n"
                f"**Exemplo de PoC/Cen√°rio de Explora√ß√£o (se aplic√°vel):** Descreva os passos para explorar a vulnerabilidade ou o risco de exposi√ß√£o da informa√ß√£o. Forne√ßa exemplos de payloads, comandos ou trechos de c√≥digo que demonstrem o problema. Para informa√ß√µes sens√≠veis, explique como essa exposi√ß√£o pode ser explorada (ex: acesso a sistemas, reconhecimento, pivotagem, uso indevido da API exposta).\n"
                f"Encapsule os exemplos de c√≥digo em blocos de c√≥digo Markdown (` ```{effective_language} ` ou ` ```bash ` ou ` ```http `).\n\n"
                f"**Ferramentas Sugeridas (se aplic√°vel):** Liste ferramentas que podem ser usadas para explorar ou validar este achado. (Ex: `grep` para buscas de strings, `curl` para testar URLs, Burp Suite para replay/modifica√ß√£o, `JSScanner`, `gitleaks` para reposit√≥rios).\n\n"
                f"**Recomenda√ß√£o/Mitiga√ß√£o:** A√ß√µes concretas, detalhadas e espec√≠ficas para corrigir o problema ou mitigar o risco (ex: mover secrets para vari√°veis de ambiente/cofre, usar autentica√ß√£o baseada em tokens tempor√°rios, sanitizar input, configurar permiss√µes adequadas, remover diret√≥rios desnecess√°rios).\n\n"
                f"Se n√£o encontrar vulnerabilidades √≥bvias ou informa√ß√µes sens√≠veis, indique isso claramente. Lembre-se, sua an√°lise √© uma *primeira linha* e n√£o substitui um SAST completo ou uma revis√£o de c√≥digo manual profunda.\n\n"
            )

            code_analysis_raw = obter_resposta_llm(llm_model_text, [code_prompt])

            if code_analysis_raw:
                st.session_state.code_analysis_result = code_analysis_raw
                logging.info("Static Code Analyzer: An√°lise de c√≥digo/conte√∫do conclu√≠da com sucesso.")
            else:
                st.session_state.code_analysis_result = "N√£o foi poss√≠vel obter a an√°lise de c√≥digo. Tente novamente."
                logging.error("Static Code Analyzer: Falha na obten√ß√£o da an√°lise de c√≥digo/conte√∫do do LLM.")

    if st.session_state.code_analysis_result:
        st.subheader("Results da An√°lise de C√≥digo/Conte√∫do")
        st.markdown(st.session_state.code_analysis_result)
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="static_code_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Static Code Analyzer: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="static_code_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Static Code Analyzer: Precisa de Melhoria.")


def swagger_openapi_analyzer_page(llm_model_vision, llm_model_text):
    st.header("OpenAPI Analyzer: An√°lise de APIs (Swagger/OpenAPI) üìÑ")
    st.markdown("""
    Cole o conte√∫do de um arquivo OpenAPI (JSON ou YAML) para analisar a especifica√ß√£o da API em busca de:
    - **Vulnerabilidades OWASP API Security Top 10 (2023)**
    - Falhas de design e implementa√ß√£o
    - Exposi√ß√£o de informa√ß√µes sens√≠veis
    - Boas pr√°ticas de seguran√ßa e sugest√µes de melhoria
    """)

    logging.info("P√°gina OpenAPI Analyzer acessada.")

    # Inicializar vari√°veis de sess√£o
    if 'swagger_input_content' not in st.session_state:
        st.session_state.swagger_input_content = ""
    if 'swagger_analysis_result_display' not in st.session_state:
        st.session_state.swagger_analysis_result_display = ""
    if 'swagger_context_input' not in st.session_state:
        st.session_state.swagger_context_input = ""
    if 'swagger_summary' not in st.session_state:
        st.session_state.swagger_summary = None

    def reset_swagger_analyzer():
        st.session_state.swagger_input_content = ""
        st.session_state.swagger_analysis_result_display = ""
        st.session_state.swagger_context_input = ""
        st.session_state.swagger_summary = None
        logging.info("OpenAPI Analyzer: Reset de campos.")
        st.rerun()

    if st.button("Limpar An√°lise OpenAPI", key="reset_swagger_analysis_button"):
        reset_swagger_analyzer()

    # Entrada de conte√∫do OpenAPI
    st.session_state.swagger_input_content = st.text_area(
        "Cole o conte√∫do do arquivo OpenAPI (JSON ou YAML) aqui:",
        value=st.session_state.swagger_input_content,
        placeholder="Ex: { 'openapi': '3.0.0', 'info': { ... }, 'paths': { ... } }",
        height=400,
        key="swagger_input_area"
    )

    # Contexto adicional opcional
    st.session_state.swagger_context_input = st.text_area(
        "Contexto Adicional (opcional):",
        value=st.session_state.swagger_context_input,
        placeholder="Ex: 'Esta API √© para gerenciamento de usu√°rios', '√â uma API interna para microservi√ßos'",
        height=150,
        key="swagger_context_input_area"
    )

    if st.button("Analisar OpenAPI", key="analyze_swagger_button"):
        if not st.session_state.swagger_input_content.strip():
            st.error("Por favor, cole o conte√∫do OpenAPI/Swagger para an√°lise.")
            logging.warning("OpenAPI Analyzer: An√°lise abortada, conte√∫do vazio.")
            return

        with st.spinner("Analisando especifica√ß√£o OpenAPI/Swagger..."):
            logging.info("OpenAPI Analyzer: Iniciando an√°lise de especifica√ß√£o.")

            # Detectar formato do conte√∫do
            content_format = "TEXTO SIMPLES (formato inv√°lido, an√°lise pode ser limitada)"
            code_lang = "plaintext"
            try:
                json.loads(st.session_state.swagger_input_content)
                content_format = "JSON"
                code_lang = "json"
            except json.JSONDecodeError:
                try:
                    yaml.safe_load(st.session_state.swagger_input_content)
                    content_format = "YAML"
                    code_lang = "yaml"
                except yaml.YAMLError:
                    st.warning("O conte√∫do colado n√£o parece ser um JSON ou YAML v√°lido. A an√°lise pode ser limitada.")
                    logging.warning("OpenAPI Analyzer: Conte√∫do n√£o √© JSON ou YAML v√°lido.")

            # Prompt para o LLM
            global_context_prompt = get_global_context_prompt()
            swagger_prompt = (
                f"Voc√™ √© um especialista em seguran√ßa de APIs e pentest, com profundo conhecimento na OWASP API Security Top 10 (2023). "
                f"{global_context_prompt} \n\n"
                f"Sua tarefa √© analisar a especifica√ß√£o OpenAPI (Swagger) fornecida ({content_format}) e o contexto adicional: '{st.session_state.swagger_context_input}', identificando **TODAS as poss√≠veis vulnerabilidades de seguran√ßa e falhas de design**.\n\n"
                f"Para cada vulnerabilidade/falha identificada, forne√ßa os seguintes t√≥picos de forma separada e concisa, utilizando Markdown. **Comece cada achado com um cabe√ßalho `###`:**\n\n"
                f"### [Nome da Vulnerabilidade/Falha de Design]\n"
                f"**Categoria OWASP API Security Top 10 (2023):** [Ex: API1: Broken Object Level Authorization (BOLA), API8: Security Misconfiguration]. Se n√£o se encaixa diretamente, use 'Falha de Design Geral'.\n"
                f"**Severidade/Risco:** [Cr√≠tica/Alta/M√©dia/Baixa - explique o impacto espec√≠fico para esta API]\n"
                f"**Localiza√ß√£o na Especifica√ß√£o:** Indique o caminho exato ou uma descri√ß√£o clara de onde a falha foi observada na especifica√ß√£o OpenAPI (ex: `/paths/{{userId}}/details GET`, `components/schemas/UserObject`).\n"
                f"**Exemplo de Explora√ß√£o:** Descreva como um atacante poderia explorar a vulnerabilidade. Forne√ßa um comando simples, um payload ou uma explica√ß√£o de como testar/explorar.\n"
                f"**Recomenda√ß√£o/Mitiga√ß√£o:** A√ß√µes concretas e espec√≠ficas para corrigir a vulnerabilidade ou melhorar o design da API, relevantes para a especifica√ß√£o OpenAPI fornecida.\n"
                f"\n"
                f"**Conte√∫do da Especifica√ß√£o OpenAPI/Swagger (para sua refer√™ncia):**\n"
                f"```{code_lang}\n{st.session_state.swagger_input_content}\n```\n\n"
                f"Se n√£o encontrar vulnerabilidades √≥bvias, indique isso claramente e sugira melhorias gerais de seguran√ßa."
            )

            # Obter resposta do LLM
            analysis_raw = obter_resposta_llm(llm_model_text, [swagger_prompt])
            if analysis_raw:
                st.session_state.swagger_analysis_result_display = analysis_raw

                # Extrair resumo
                summary_match = re.search(
                    r'Total de Vulnerabilidades API:\s*(\d+)\s*\|\s*Cr√≠ticas:\s*(\d+)\s*\|\s*Altas:\s*(\d+)\s*\|\s*M√©dios:\s*(\d+)\s*\|\s*Baixos:\s*(\d+)',
                    analysis_raw
                )
                if summary_match:
                    total, criticos, altos, medios, baixos = map(int, summary_match.groups())
                    st.session_state.swagger_summary = {
                        "Total": total,
                        "Cr√≠ticas": criticos,
                        "Altas": altos,
                        "M√©dios": medios,
                        "Baixos": baixos
                    }
                else:
                    st.session_state.swagger_summary = {"Total": 0, "Cr√≠ticas": 0, "Altas": 0, "M√©dios": 0, "Baixos": 0}
                    logging.warning("OpenAPI Analyzer: Resumo de vulnerabilidades n√£o encontrado na resposta do LLM.")
            else:
                st.session_state.swagger_analysis_result_display = "N√£o foi poss√≠vel obter a an√°lise da especifica√ß√£o OpenAPI. Tente novamente."
                st.session_state.swagger_summary = None
                logging.error("OpenAPI Analyzer: Falha na obten√ß√£o da an√°lise do LLM.")

    # Exibir resultados
    if st.session_state.swagger_analysis_result_display:
        st.subheader("Resultados da An√°lise OpenAPI")

        if st.session_state.swagger_summary:
            cols = st.columns(5)
            cols[0].metric("Total", st.session_state.swagger_summary.get("Total", 0))
            cols[1].metric("Cr√≠ticas", st.session_state.swagger_summary.get("Cr√≠ticas", 0))
            cols[2].metric("Altas", st.session_state.swagger_summary.get("Altas", 0))
            cols[3].metric("M√©dios", st.session_state.swagger_summary.get("M√©dios", 0))
            cols[4].metric("Baixos", st.session_state.swagger_summary.get("Baixos", 0))

        # Exibir detalhes das vulnerabilidades
        st.markdown(st.session_state.swagger_analysis_result_display)

        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="swagger_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback OpenAPI Analyzer: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="swagger_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback OpenAPI Analyzer: Precisa de Melhoria.")


def tactical_command_orchestrator_page(llm_model_text):
    st.header("Tactical Command Orchestrator ü§ñ")
    st.markdown("""
        Descreva o seu cen√°rio de pentest, o alvo, e qual ferramenta ou tipo de a√ß√£o voc√™ precisa.
        O HuntIA ir√° sugerir os comandos mais eficazes e otimizados, adaptados ao seu ambiente e objetivo.
    """)
    logging.info("P√°gina Tactical Command Orchestrator acessada.")

    if 'command_scenario_input' not in st.session_state:
        st.session_state.command_scenario_input = ""
    if 'command_analysis_result' not in st.session_state:
        st.session_state.command_analysis_result = ""
    if 'command_tool_selection' not in st.session_state:
        st.session_state.command_tool_selection = "Qualquer Ferramenta"
    if 'command_os_selection' not in st.session_state:
        st.session_state.command_os_selection = "Linux/macOS (Bash)"

    def reset_command_orchestrator():
        st.session_state.command_scenario_input = ""
        st.session_state.command_analysis_result = ""
        st.session_state.command_tool_selection = "Qualquer Ferramenta"
        st.session_state.command_os_selection = "Linux/macOS (Bash)"
        logging.info("Tactical Command Orchestrator: Reset de campos.")
        st.rerun()

    if st.button("Limpar Orquestrador", key="reset_command_orchestrator_button"):
        reset_command_orchestrator()

    scenario_input = st.text_area(
        "Descreva o cen√°rio e seu objetivo (Ex: 'Preciso de um comando Nmap para escanear portas UDP em 192.168.1.100', 'Como fa√ßo um brute-force de login em um formul√°rio web com Hydra?'):",
        value=st.session_state.command_scenario_input,
        placeholder="Ex: Escanear portas TCP em um host, encontrar diret√≥rios ocultos, criar payload de shell reverso.",
        height=150,
        key="command_scenario_input_area"
    )
    st.session_state.command_scenario_input = scenario_input.strip()

    tool_options = [
        "Qualquer Ferramenta", "Nmap", "Metasploit", "Burp Suite (comandos curl/HTTP)",
        "SQLmap", "Hydra", "ffuf", "Nuclei", "Subfinder", "Httpx", "Wpscan", "Other"
    ]
    selected_tool = st.selectbox(
        "Ferramenta Preferida (Opcional):",
        options=tool_options,
        index=tool_options.index(st.session_state.command_tool_selection),
        key="command_tool_select"
    )
    st.session_state.command_tool_selection = selected_tool

    os_options = ["Linux/macOS (Bash)", "Windows (PowerShell/CMD)"]
    selected_os = st.selectbox(
        "Sistema Operacional para o Comando:",
        options=os_options,
        index=os_options.index(st.session_state.command_os_selection),
        key="command_os_select"
    )
    st.session_state.command_os_selection = selected_os

    if st.button("Gerar Comando T√°tico", key="generate_command_button"):
        if not st.session_state.command_scenario_input:
            st.error("Por favor, descreva o cen√°rio para gerar o comando.")
            logging.warning("Tactical Command Orchestrator: Gera√ß√£o abortada, cen√°rio vazio.")
            return
        else:
            with st.spinner("Gerando comando t√°tico otimizado..."):
                logging.info(f"Tactical Command Orchestrator: Gerando comando para cen√°rio '{st.session_state.command_scenario_input}'.")
                target_tool_text = f"Usando a ferramenta '{st.session_state.command_tool_selection}'." if st.session_state.command_tool_selection != "Qualquer Ferramenta" else ""
                target_os_text = f"O comando deve ser para o sistema operacional '{st.session_state.command_os_selection}'."
                
                # --- INJETANDO O CONTEXTO GLOBAL ---
                global_context_prompt = get_global_context_prompt()
                # --- FIM INJE√á√ÉO DE CONTEXTO ---


                command_prompt = (
                    f"Voc√™ √© um especialista em pentest e automa√ß√£o, com vasto conhecimento em ferramentas de linha de comando. "
                    f"{global_context_prompt}" # INJETANDO CONTEXTO GLOBAL
                    f"\n\nSua tarefa √© gerar um comando de linha de comando preciso e otimizado para o seguinte cen√°rio:\n"
                    f"**Cen√°rio do Usu√°rio:** '{st.session_state.command_scenario_input}'.\n"
                    f"{target_tool_text}\n"
                    f"{target_os_text}"
                    f"\n\nForne√ßa as seguintes informa√ß√µes em Markdown:\n\n"
                    f"## 1. Comando Sugerido\n"
                    f"Apresente o comando COMPLETO e PRONTO PARA USO. Encapsule-o em um bloco de c√≥digo Markdown (` ```bash `, ` ```powershell `, ` ```cmd ` ou similar, de acordo com o OS). "
                    f"Inclua todos os par√¢metros necess√°rios e exemplos de placeholder (ex: `<IP_ALVO>`, `<USUARIO>`, `<SENHA_LIST>`).\n\n"
                    f"## 2. Explica√ß√£o do Comando\n"
                    f"Explique cada parte do comando, seus par√¢metros e por que ele √© eficaz para o cen√°rio. Detalhe como o usu√°rio pode adapt√°-lo.\n\n"
                    f"## 3. Observa√ß√µes de Seguran√ßa/Melhores Pr√°ticas\n"
                    f"Adicione quaisquer observa√ß√µes de seguran√ßa, como a necessidade de autoriza√ß√£o, riscos potenciais, ou considera√ß√µes sobre o ambiente (ex: firewalls, WAFs). Sugira varia√ß√µes ou pr√≥ximos passos.\n\n"
                    f"Seu objetivo √© ser extremamente pr√°tico, √∫til e direto. Se o cen√°rio for invi√°vel ou muito gen√©rico, explique por que e sugira um refinamento."
                )

                command_result_raw = obter_resposta_llm(llm_model_text, [command_prompt])

                if command_result_raw:
                    st.session_state.command_analysis_result = command_result_raw
                    logging.info("Tactical Command Orchestrator: Comando gerado com sucesso.")
                else:
                    st.session_state.command_analysis_result = "N√£o foi poss√≠vel gerar o comando. Tente refinar a descri√ß√£o do cen√°rio."
                    logging.error("Tactical Command Orchestrator: Falha ao gerar comando pelo LLM.")

    if st.session_state.command_analysis_result:
        st.subheader("Comando T√°tico Gerado")
        st.markdown(st.session_state.command_analysis_result)
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="command_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Tactical Command Orchestrator: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="command_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Tactical Command Orchestrator: Precisa de Melhoria.")


def pentest_playbook_generator_page(llm_model_text):
    st.header("Pentest Playbook Generator üìñ")
    st.markdown("""
        Descreva o escopo e os objetivos do seu pentest, e o HuntIA ir√° gerar um playbook
        com etapas sugeridas, ferramentas e considera√ß√µes para cada fase do teste de intrus√£o.
        **ATEN√á√ÉO:** Este playbook √© um guia e deve ser adaptado √† sua metodologia e ao ambiente real.
    """)
    logging.info("P√°gina Pentest Playbook Generator acessada.")

    # Inicializa√ß√£o de vari√°veis de estado
    if 'playbook_scope' not in st.session_state:
        st.session_state.playbook_scope = ""
    if 'playbook_objectives' not in st.session_state:
        st.session_state.playbook_objectives = ""
    if 'playbook_output' not in st.session_state:
        st.session_state.playbook_output = ""

    def reset_playbook_generator():
        st.session_state.playbook_scope = ""
        st.session_state.playbook_objectives = ""
        st.session_state.playbook_output = ""
        logging.info("Pentest Playbook Generator: Reset de campos.")
        st.rerun()

    if st.button("Limpar Playbook", key="reset_playbook_button"):
        reset_playbook_generator()

    scope_input = st.text_area(
        "Escopo do Pentest (ex: 'Aplica√ß√£o web e API REST', 'Rede interna', 'Ambiente de nuvem AWS'):",
        value=st.session_state.playbook_scope,
        placeholder="Ex: Sistema web de e-commerce, IP 192.168.1.0/24",
        height=100,
        key="playbook_scope_input"
    )
    st.session_state.playbook_scope = scope_input.strip()

    objectives_input = st.text_area(
        "Objetivos do Pentest (ex: 'Obter acesso a dados de clientes', 'Comprometer servidor web', 'Escalada de privil√©gios'):",
        value=st.session_state.playbook_objectives,
        placeholder="Ex: Identificar XSS e SQLi, testar controle de acesso, validar configura√ß√µes de seguran√ßa",
        height=100,
        key="playbook_objectives_input"
    )
    st.session_state.playbook_objectives = objectives_input.strip()

    if st.button("Gerar Playbook", key="generate_playbook_button"):
        if not st.session_state.playbook_scope or not st.session_state.playbook_objectives:
            st.error("Por favor, forne√ßa o escopo e os objetivos do pentest.")
            logging.warning("Pentest Playbook Generator: Gera√ß√£o abortada, escopo/objetivos vazios.")
            return
        else:
            with st.spinner("Gerando playbook de pentest..."):
                logging.info("Pentest Playbook Generator: Iniciando gera√ß√£o do playbook.")

                # --- INJETANDO O CONTEXTO GLOBAL ---
                global_context_prompt = get_global_context_prompt()
                # --- FIM INJE√á√ÉO DE CONTEXTO ---

                playbook_prompt = (
                    f"Voc√™ √© um especialista em testes de intrus√£o, com profundo conhecimento em metodologias de pentest (OSSTMM, PTES, OWASP TOP 10, MITRE ATT&CK)."
                    f"{global_context_prompt}" # INJETANDO CONTEXTO GLOBAL
                    f"\n\nSua tarefa √© gerar um playbook detalhado para um pentest com o seguinte escopo e objetivos:\n\n"
                    f"**Escopo:** {st.session_state.playbook_scope}\n"
                    f"**Objetivos:** {st.session_state.playbook_objectives}\n"
                    f"\n\nO playbook deve cobrir as principais fases de um pentest e, para cada fase/se√ß√£o, incluir:\n"
                    f"- **Descri√ß√£o:** O que esta fase envolve.\n"
                    f"- **Passos Chave:** A√ß√µes detalhadas a serem tomadas.\n"
                    f"- **Ferramentas Sugeridas:** Ferramentas espec√≠ficas e comandos de exemplo (quando aplic√°vel, em blocos de c√≥digo markdown).\n"
                    f"- **Resultados Esperados:** O que procurar ou coletar.\n"
                    f"- **Considera√ß√µes de Seguran√ßa/√âtica:** Alertas e boas pr√°ticas.\n\n"
                    f"As fases a serem abordadas incluem (mas n√£o se limitam a):"
                    f"1.  **Reconhecimento (Passivo e Ativo)**\n"
                    f"2.  **Mapeamento/Enumera√ß√£o**\n"
                    f"3.  **An√°lise de Vulnerabilidades**\n"
                    f"4.  **Explora√ß√£o**\n"
                    f"5.  **P√≥s-Explora√ß√£o (Se aplic√°vel, com foco em persist√™ncia, eleva√ß√£o de privil√©gios, movimento lateral, coleta de dados)**\n"
                    f"6.  **Gera√ß√£o de Relat√≥rio**\n\n"
                    f"Seja conciso, pr√°tico e acion√°vel. Use Markdown para t√≠tulos e formata√ß√£o clara. Inclua exemplos de comandos quando fizer sentido (ex: Nmap, dirb, SQLmap, Metasploit, etc.)."
                )

                playbook_raw = obter_resposta_llm(llm_model_text, [playbook_prompt])

                if playbook_raw:
                    st.session_state.playbook_output = playbook_raw
                    logging.info("Pentest Playbook Generator: Playbook gerado com sucesso.")
                else:
                    st.session_state.playbook_output = "N√£o foi poss√≠vel gerar o playbook. Tente refinar o escopo e os objetivos."
                    logging.error("Pentest Playbook Generator: Falha na gera√ß√£o do playbook pelo LLM.")

    if st.session_state.playbook_output:
        st.subheader("Playbook de Pentest Gerado")
        st.markdown(st.session_state.playbook_output)
        
        # Bot√£o para download
        st.download_button(
            label="Download Playbook (.md)",
            data=st.session_state.playbook_output.encode('utf-8'),
            file_name=f"pentest_playbook_{re.sub(r'[^a-zA-Z0-9_]', '', st.session_state.playbook_scope[:20])}_{int(time.time())}.md",
            mime="text/markdown",
            help="Baixa o playbook gerado em formato Markdown."
        )
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="playbook_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Pentest Playbook Generator: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="playbook_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Pentest Playbook Generator: Precisa de Melhoria.")


def intelligent_pentest_validator_page(llm_model_vision, llm_model_text):
    st.header("Intelligent Pentest Validator üìä")
    st.markdown("""
        Fa√ßa upload das evid√™ncias do seu pentest (prints de tela, resultados de ferramentas) com descri√ß√µes.
        O HuntIA usar√° o LLM para analisar se o pentest cobriu o escopo/objetivos e sugerir melhorias.
    """)
    logging.info("P√°gina Intelligent Pentest Validator acessada.")

    # Inicializa√ß√£o de vari√°veis de estado para a p√°gina
    if 'validation_scope' not in st.session_state: st.session_state.validation_scope = ""
    if 'validation_objectives' not in st.session_state: st.session_state.validation_objectives = ""
    if 'uploaded_evidences' not in st.session_state: st.session_state.uploaded_evidences = [] # Lista de {'image': Image.obj, 'description': str, 'name': str, 'id': str}
    if 'validation_llm_result' not in st.session_state: st.session_state.validation_llm_result = ""
    if 'validation_summary' not in st.session_state: st.session_state.validation_summary = None
    if 'overall_pentest_summary' not in st.session_state: st.session_state.overall_pentest_summary = ""

    def reset_validation():
        st.session_state.validation_scope = ""
        st.session_state.validation_objectives = ""
        st.session_state.uploaded_evidences = []
        st.session_state.validation_llm_result = ""
        st.session_state.validation_summary = None
        st.session_state.overall_pentest_summary = ""
        logging.info("Intelligent Pentest Validator: Reset de campos.")
        st.rerun()

    if st.button("Limpar e Nova Valida√ß√£o", key="reset_validation_button"):
        reset_validation()

    st.subheader("1. Defina o Escopo e Objetivos do Pentest")
    st.session_state.validation_scope = st.text_area(
        "Escopo do Pentest (Ex: 'Aplica√ß√£o web de e-commerce', 'Rede interna com 10 hosts'):",
        value=st.session_state.validation_scope,
        placeholder="Ex: API REST de pagamentos, rede corporativa.",
        height=70,
        key="validation_scope_input"
    )

    st.session_state.validation_objectives = st.text_area(
        "Objetivos do Pentest (Ex: 'Identificar todas as inje√ß√µes', 'Obter acesso de administrador', 'Validar hardening'):",
        value=st.session_state.validation_objectives,
        placeholder="Ex: Descobrir credenciais vazadas, testar falhas de l√≥gica de neg√≥cio.",
        height=70,
        key="validation_objectives_input"
    )
    
    st.session_state.overall_pentest_summary = st.text_area(
        "Resumo Geral do Pentest (Opcional, mas √∫til para o LLM - Principais achados, metodologia utilizada, etc.):",
        value=st.session_state.overall_pentest_summary,
        placeholder="Ex: 'Pentest de caixa preta focado em OWASP Top 10. Encontrei 2 XSS, 1 IDOR e uma misconfiguration no Apache.'",
        height=150,
        key="overall_pentest_summary_input"
    )

    st.subheader("2. Fa√ßa Upload de Suas Evid√™ncias (Imagens e Descri√ß√µes)")
    new_uploaded_files = st.file_uploader(
        "Adicione imagens de evid√™ncia (JPG, JPEG, PNG). Voc√™ pode adicionar v√°rias de uma vez.",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        key="validation_evidence_uploader"
    )

    if new_uploaded_files:
        existing_file_fingerprints = {(e['name'], e['image'].size) for e in st.session_state.uploaded_evidences if 'name' in e and 'image' in e}
        
        for uploaded_file in new_uploaded_files:
            try:
                img_bytes = uploaded_file.getvalue()
                img = Image.open(BytesIO(img_bytes))
                
                file_fingerprint = (uploaded_file.name, img.size) 
                
                if file_fingerprint not in existing_file_fingerprints:
                    st.session_state.uploaded_evidences.append({
                        'image': img,
                        'description': "",
                        'name': uploaded_file.name,
                        'id': str(uuid.uuid4())
                    })
                    logging.info(f"Intelligent Pentest Validator: Evid√™ncia '{uploaded_file.name}' carregada.")
                else:
                    st.info(f"Arquivo '{uploaded_file.name}' j√° carregado. Ignorando duplicata.")
                    logging.info(f"Intelligent Pentest Validator: Evid√™ncia '{uploaded_file.name}' duplicada ignorada.")
            except Exception as e:
                st.error(f"Erro ao carregar a imagem {uploaded_file.name}: {e}")
                logging.error(f"Intelligent Pentest Validator: Erro ao carregar evid√™ncia '{uploaded_file.name}': {e}.")

    if st.session_state.uploaded_evidences:
        st.markdown("#### Evid√™ncias Carregadas:")
        evidences_to_remove = []
        for i, evidence in enumerate(st.session_state.uploaded_evidences):
            col1, col2 = st.columns([3, 1])
            with col1:
                st.image(evidence['image'], caption=f"Evid√™ncia {i+1}: {evidence['name']}", use_container_width=True)
            with col2:
                description_key = f"evidence_description_{evidence['id']}"
                evidence['description'] = st.text_area(
                    "Descreva esta evid√™ncia (o que ela mostra?):",
                    value=evidence['description'],
                    key=description_key,
                    height=100
                )
                if st.button(f"Remover Evid√™ncia {i+1}", key=f"remove_evidence_btn_{evidence['id']}"):
                    evidences_to_remove.append(i)
        
        if evidences_to_remove:
            for index in sorted(evidences_to_remove, reverse=True):
                logging.info(f"Intelligent Pentest Validator: Evid√™ncia '{st.session_state.uploaded_evidences[index].get('name', 'N/A')}' removida.")
                del st.session_state.uploaded_evidences[index]
            st.rerun()

    st.subheader("3. Iniciar Valida√ß√£o do Pentest")
    if st.button("Validar Pentest com LLM", key="validate_pentest_button"):
        if not st.session_state.validation_scope:
            st.error("Por favor, preencha o escopo do pentest.")
            logging.warning("Intelligent Pentest Validator: Valida√ß√£o abortada, escopo vazio.")
            return
        if not st.session_state.validation_objectives:
            st.error("Por favor, preencha os objetivos do pentest.")
            logging.warning("Intelligent Pentest Validator: Valida√ß√£o abortada, objetivos vazios.")
            return
        elif not st.session_state.uploaded_evidences:
            st.error("Por favor, fa√ßa upload de pelo menos uma evid√™ncia.")
            logging.warning("Intelligent Pentest Validator: Valida√ß√£o abortada, nenhuma evid√™ncia carregada.")
            return
        else:
            with st.spinner("Realizando valida√ß√£o inteligente do pentest..."):
                logging.info(f"Intelligent Pentest Validator: Iniciando valida√ß√£o com {len(st.session_state.uploaded_evidences)} evid√™ncias.")

                # --- INJETANDO O CONTEXTO GLOBAL ---
                global_context_prompt = get_global_context_prompt()
                # --- FIM INJE√á√ÉO DE CONTEXTO ---

                llm_input_parts = [
                    f"Voc√™ √© um revisor de qualidade de pentests e um especialista em seguran√ßa. "
                    f"{global_context_prompt}" # INJETANDO CONTEXTO GLOBAL
                    f"\n\nSua tarefa √© analisar o escopo, os objetivos e as evid√™ncias (imagens com descri√ß√µes) de um pentest, e fornecer uma avalia√ß√£o detalhada da sua completude e qualidade."
                    f"**Escopo do Pentest:** {st.session_state.validation_scope}\n"
                    f"**Objetivos:** {st.session_state.validation_objectives}\n"
                    f"**Resumo Geral do Pentest (Fornecido pelo Pentester):** {st.session_state.overall_pentest_summary if st.session_state.overall_pentest_summary else 'Nenhum resumo geral fornecido.'}\n"
                    f"\n\n**Instru√ß√µes para An√°lise:**\n"
                    f"1.  **Avalie a Cobertura:** Com base no escopo e objetivos, avalie se as evid√™ncias indicam que o pentest cobriu as √°reas esperadas.\n"
                    f"2.  **Qualidade das Evid√™ncias:** Avalie se as evid√™ncias s√£o claras, suficientes e relevantes para comprovar as atividades/achados.\n"
                    f"3.  **Identifique Lacunas:** Aponte explicitamente qualquer √°rea que pare√ßa ter sido negligenciada, insuficientemente testada ou mal documentada, dada a natureza do pentest.\n"
                    f"4.  **Sugest√µes de Melhoria:** Forne√ßa sugest√µes concretas para melhorar o pentest ou a documenta√ß√£o, incluindo poss√≠veis ferramentas ou t√©cnicas adicionais.\n"
                    f"5.  **Critique a Explora√ß√£o/Documenta√ß√£o de Vulnerabilidades:** Se vulnerabilidades s√£o mencionadas, avalie se a explora√ß√£o parece completa e se h√° PoCs claras.\n\n"
                    f"**Formato da Resposta:**\n"
                    f"**RESUMO GERAL DO STATUS DO PENTEST:** Forne√ßa um resumo quantitativo na PRIMEIRA LINHA da sua resposta, no formato exato: `Total de Achados de Valida√ß√£o: X | Cobertura Alta: Y | Cobertura M√©dia: Z | Cobertura Baixa: W | Lacunas: V` (substitua X,Y,Z,W,V pelos n√∫meros correspondentes). 'Total de Achados de Valida√ß√£o' refere-se aos pontos de feedback. 'Cobertura' refere-se √† abrang√™ncia do pentest, e 'Lacunas' s√£o as √°reas que faltaram.\n\n"
                    f"Para cada ponto de feedback, use o seguinte formato Markdown:\n"
                    f"## [Tipo de Feedback] (Ex: Cobertura OK, Lacuna Identificada, Sugest√£o de Melhoria)\n"
                    f"**Categoria:** [Cobertura/Qualidade/Lacuna/Sugest√£o/Vulnerabilidade Espec√≠fica]\n"
                    f"**N√≠vel de Import√¢ncia:** [Cr√≠tico/Alto/M√©dio/Baixo/Informativo]\n"
                    f"**Detalhes:** [Explique o feedback, referenciando as evid√™ncias por 'Evid√™ncia [N√∫mero da Imagem]' e sua descri√ß√£o. Ex: 'Evid√™ncia 3 ('Scan de Nmap') mostra uma boa cobertura de portas, indicando um reconhecimento ativo s√≥lido.']\n"
                    f"**Recomenda√ß√£o/A√ß√£o:** [Sugira o que deve ser feito para resolver uma lacuna ou melhorar um ponto. Inclua ferramentas/comandos se aplic√°vel.]\n\n"
                    f"--- Evid√™ncias Fornecidas ---\n"
                ]

                for i, evidence in enumerate(st.session_state.uploaded_evidences):
                    llm_input_parts.append(f"Evid√™ncia {i+1} (Nome: {evidence['name']}): {evidence['description']}\n")
                    llm_input_parts.append(evidence['image'])
                
                validation_raw_result = obter_resposta_llm(llm_model_vision, llm_input_parts)

                if validation_raw_result:
                    st.session_state.validation_summary, st.session_state.validation_llm_result = parse_vulnerability_summary(validation_raw_result)
                    if st.session_state.validation_summary:
                        st.session_state.validation_summary_display = {
                            "Total de Achados de Valida√ß√£o": st.session_state.validation_summary.get("Total", 0),
                            "Cobertura Alta": st.session_state.validation_summary.get("Cobertura Alta", 0),
                            "Cobertura M√©dia": st.session_state.validation_summary.get("Cobertura M√©dia", 0),
                            "Cobertura Baixa": st.session_state.validation_summary.get("Cobertura Baixa", 0),
                            "Lacunas": st.session_state.validation_summary.get("Lacunas", 0)
                        }
                    logging.info("Intelligent Pentest Validator: Valida√ß√£o conclu√≠da com sucesso.")
                else:
                    st.session_state.validation_llm_result = "N√£o foi poss√≠vel obter a valida√ß√£o do pentest. Tente refinar as informa√ß√µes."
                    st.session_state.validation_summary = None
                    logging.error("Intelligent Pentest Validator: Falha na obten√ß√£o da valida√ß√£o do LLM.")

    if st.session_state.validation_llm_result:
        st.subheader("Resultados da Valida√ß√£o do Pentest")
        if st.session_state.validation_summary and getattr(st.session_state, 'validation_summary_display', None):
            cols = st.columns(5)
            cols[0].metric("Total Achados", st.session_state.validation_summary_display["Total de Achados de Valida√ß√£o"])
            cols[1].metric("Cobertura Alta", st.session_state.validation_summary_display["Cobertura Alta"])
            cols[2].metric("Cobertura M√©dia", st.session_state.validation_summary_display["Cobertura M√©dia"])
            cols[3].metric("Cobertura Baixa", st.session_state.validation_summary_display["Cobertura Baixa"])
            cols[4].metric("Lacunas", st.session_state.validation_summary_display["Lacunas"])
            st.markdown("---")
        else:
            st.warning("N√£o foi poss√≠vel exibir o resumo da valida√ß√£o. Formato inesperado do LLM ou erro na an√°lise.")

        st.markdown(st.session_state.validation_llm_result)
        
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="validation_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Intelligent Pentest Validator: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="validation_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Intelligent Pentest Validator: Precisa de Melhoria.")



def pentest_narrative_generator_page(llm_model_vision, llm_model_text):
    st.header("Pentest Narrative Generator üìù")
    st.markdown("""
        Gere uma narrativa de relat√≥rio de pentest abrangente e profissional, combinando
        detalhes do cliente/aplica√ß√£o com suas evid√™ncias de teste, agora categorizadas por fase do pentest.
        O HuntIA ir√° integrar e expandir seus achados em um texto completo, incluindo uma conclus√£o e
        refer√™ncias √†s imagens que voc√™ anexou.
    """)
    logging.info("P√°gina Pentest Narrative Generator acessada.")

    # Vari√°veis de sess√£o para esta p√°gina
    if 'narrative_client_name' not in st.session_state: st.session_state.narrative_client_name = ""
    if 'narrative_app_name' not in st.session_state: st.session_state.narrative_app_name = ""
    if 'narrative_pentest_type' not in st.session_state: st.session_state.narrative_pentest_type = "Web Application"

    # NOVOS: Listas separadas para evid√™ncias por categoria
    if 'narrative_recon_evidences' not in st.session_state: st.session_state.narrative_recon_evidences = [] # [{'image': Image, 'description': '', 'report_image_filename': '', 'raw_tool_output': '', 'id': uuid}]
    if 'narrative_vuln_evidences' not in st.session_state: st.session_state.narrative_vuln_evidences = [] # [{'image': Image, 'vulnerability_name': '', 'severity': '', 'description': '', 'report_image_filename': '', 'raw_tool_output': '', 'id': uuid}]
    if 'narrative_resilience_evidences' not in st.session_state: st.session_state.narrative_resilience_evidences = [] # [{'image': Image, 'test_name': '', 'description': '', 'report_image_filename': '', 'raw_tool_output': '', 'id': uuid}]

    if 'generated_narrative_output' not in st.session_state: st.session_state.generated_narrative_output = ""
    if 'narrative_summary_output' not in st.session_state: st.session_state.narrative_summary_output = ""


    def reset_narrative_generator():
        st.session_state.narrative_client_name = ""
        st.session_state.narrative_app_name = ""
        st.session_state.narrative_pentest_type = "Web Application"
        st.session_state.narrative_recon_evidences = [] # Reset das novas listas
        st.session_state.narrative_vuln_evidences = []
        st.session_state.narrative_resilience_evidences = []
        st.session_state.generated_narrative_output = ""
        st.session_state.narrative_summary_output = ""
        logging.info("Pentest Narrative Generator: Reset de campos.")
        st.rerun()

    if st.button("Limpar e Gerar Nova Narrativa", key="reset_narrative_button"):
        reset_narrative_generator()

    st.subheader("1. Detalhes do Projeto")
    st.session_state.narrative_client_name = st.text_input(
        "Nome do Cliente:",
        value=st.session_state.narrative_client_name,
        placeholder="Ex: Minha Empresa S.A.",
        key="narrative_client_input"
    )
    st.session_state.narrative_app_name = st.text_input(
        "Nome da Aplica√ß√£o/Sistema Testado:",
        value=st.session_state.narrative_app_name,
        placeholder="Ex: Plataforma de E-commerce",
        key="narrative_app_input"
    )
    pentest_type_options = ["Web Application", "API", "Infrastructure", "Mobile"]
    st.session_state.narrative_pentest_type = st.selectbox(
        "Tipo de Pentest Principal:",
        options=pentest_type_options,
        index=pentest_type_options.index(st.session_state.narrative_pentest_type),
        key="narrative_pentest_type_select_narrative",
        help="O LLM adaptar√° a narrativa e o foco das vulnerabilidades com base neste tipo de pentest."
    )

    st.subheader("2. Upload e Detalhamento das Evid√™ncias por Categoria")
    st.info("Para cada se√ß√£o, fa√ßa upload de imagens e detalhe os achados. O nome do arquivo da imagem ser√° usado para refer√™ncia no relat√≥rio.")

    # --- Se√ß√£o de Evid√™ncias de Reconhecimento e Mapeamento ---
    st.markdown("#### Evid√™ncias de Reconhecimento e Mapeamento")
    new_recon_files = st.file_uploader(
        "Adicionar imagens para Reconhecimento e Mapeamento:",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        key="recon_evidence_uploader"
    )
    if new_recon_files:
        existing_fingerprints = {(e['name'], e['image'].size) for e in st.session_state.narrative_recon_evidences if 'name' in e and 'image' in e}
        for uploaded_file in new_recon_files:
            try:
                img_bytes = uploaded_file.getvalue()
                img = Image.open(BytesIO(img_bytes))
                file_fingerprint = (uploaded_file.name, img.size)
                if file_fingerprint not in existing_fingerprints:
                    st.session_state.narrative_recon_evidences.append({
                        'image': img, 'description': '', 'report_image_filename': uploaded_file.name,
                        'raw_tool_output': '', 'id': str(uuid.uuid4()), 'name': uploaded_file.name
                    })
                    logging.info(f"Narrative Generator: Recon evidence '{uploaded_file.name}' loaded.")
                else: st.info(f"Arquivo '{uploaded_file.name}' j√° carregado (Recon).")
            except Exception as e: st.error(f"Erro ao carregar imagem para Recon: {e}"); logging.error(f"Narrative Generator: Error loading recon image: {e}.")
    
    recon_evidences_to_remove = []
    for i, evidence in enumerate(st.session_state.narrative_recon_evidences):
        st.markdown(f"**Recon Evid√™ncia {i+1}:** `{evidence['name']}`")
        st.image(evidence['image'], use_container_width=True)
        st.session_state.narrative_recon_evidences[i]['description'] = st.text_area(
            "Descri√ß√£o do Achado de Reconhecimento:", value=evidence['description'],
            placeholder="Ex: 'Esta imagem mostra os subdom√≠nios descobertos via OSINT, incluindo dev.exemplo.com.'",
            key=f"recon_desc_{evidence['id']}", height=70
        )
        st.session_state.narrative_recon_evidences[i]['report_image_filename'] = st.text_input(
            "Nome do Arquivo da Imagem (Ex: `subdominios.png`):", value=evidence['report_image_filename'],
            placeholder="nome-da-imagem.jpg", key=f"recon_filename_{evidence['id']}"
        )
        st.session_state.narrative_recon_evidences[i]['raw_tool_output'] = st.text_area(
            "Output Bruto da Ferramenta (Opcional para Recon):", value=evidence['raw_tool_output'],
            placeholder="Cole o output do Subfinder/Nmap/etc. aqui.",
            key=f"recon_raw_output_{evidence['id']}", height=100
        )
        if st.button(f"Remover Recon Evid√™ncia {i+1}", key=f"remove_recon_evidence_btn_{evidence['id']}"): recon_evidences_to_remove.append(i)
    for index in sorted(recon_evidences_to_remove, reverse=True): del st.session_state.narrative_recon_evidences[index]; st.rerun()

    # --- Se√ß√£o de Evid√™ncias de Vulnerabilidades Encontradas ---
    st.markdown("---")
    st.markdown("#### Evid√™ncias de Vulnerabilidades Encontradas")
    new_vuln_files = st.file_uploader(
        "Adicionar imagens para Vulnerabilidades Encontradas:",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        key="vuln_evidence_uploader"
    )
    if new_vuln_files:
        existing_fingerprints = {(e['name'], e['image'].size) for e in st.session_state.narrative_vuln_evidences if 'name' in e and 'image' in e}
        for uploaded_file in new_vuln_files:
            try:
                img_bytes = uploaded_file.getvalue()
                img = Image.open(BytesIO(img_bytes))
                file_fingerprint = (uploaded_file.name, img.size)
                if file_fingerprint not in existing_fingerprints:
                    st.session_state.narrative_vuln_evidences.append({
                        'image': img, 'vulnerability_name': '', 'severity': 'M√©dia',
                        'description': '', 'report_image_filename': uploaded_file.name,
                        'raw_tool_output': '', 'id': str(uuid.uuid4()), 'name': uploaded_file.name
                    })
                    logging.info(f"Narrative Generator: Vuln evidence '{uploaded_file.name}' loaded.")
                else: st.info(f"Arquivo '{uploaded_file.name}' j√° carregado (Vuln).")
            except Exception as e: st.error(f"Erro ao carregar imagem para Vuln: {e}"); logging.error(f"Narrative Generator: Error loading vuln image: {e}.")

    vuln_evidences_to_remove = []
    for i, evidence in enumerate(st.session_state.narrative_vuln_evidences):
        st.markdown(f"**Vulnerabilidade Evid√™ncia {i+1}:** `{evidence['name']}`")
        st.image(evidence['image'], use_container_width=True)
        st.session_state.narrative_vuln_evidences[i]['vulnerability_name'] = st.text_input(
            "Nome da Vulnerabilidade:", value=evidence['vulnerability_name'],
            placeholder="Ex: Clickjacking, SQL Injection", key=f"vuln_name_{evidence['id']}"
        )
        st.session_state.narrative_vuln_evidences[i]['severity'] = st.selectbox(
            "Severidade da Vulnerabilidade:", options=["Cr√≠tica", "Alta", "M√©dia", "Baixa", "Informativa"],
            index=["Cr√≠tica", "Alta", "M√©dia", "Baixa", "Informativa"].index(evidence['severity']),
            key=f"vuln_severity_{evidence['id']}"
        )
        st.session_state.narrative_vuln_evidences[i]['description'] = st.text_area(
            "Descri√ß√£o do Problema (como foi explorada, impacto):", value=evidence['description'],
            placeholder="Ex: 'Foi poss√≠vel sobrepor a p√°gina de login e induzir cliques no bot√£o de submiss√£o, evid√™ncia de Clickjacking.'",
            key=f"vuln_desc_{evidence['id']}", height=100
        )
        st.session_state.narrative_vuln_evidences[i]['report_image_filename'] = st.text_input(
            "Nome do Arquivo da Imagem (Ex: `clickjacking_poc.png`):", value=evidence['report_image_filename'],
            placeholder="nome-da-imagem.jpg", key=f"vuln_filename_{evidence['id']}"
        )
        st.session_state.narrative_vuln_evidences[i]['raw_tool_output'] = st.text_area(
            "Output Bruto da Ferramenta (Opcional para Vuln):", value=evidence['raw_tool_output'],
            placeholder="Cole o output do Burp, Acunetix, etc. aqui.",
            key=f"vuln_raw_output_{evidence['id']}", height=100
        )
        if st.button(f"Remover Vuln Evid√™ncia {i+1}", key=f"remove_vuln_evidence_btn_{evidence['id']}"): vuln_evidences_to_remove.append(i)
    for index in sorted(vuln_evidences_to_remove, reverse=True): del st.session_state.narrative_vuln_evidences[index]; st.rerun()

    # --- Se√ß√£o de Evid√™ncias de Testes de Resili√™ncia (Sem Falha) ---
    st.markdown("---")
    st.markdown("#### Evid√™ncias de Testes de Resili√™ncia (Sem Falha)")
    new_resilience_files = st.file_uploader(
        "Adicionar imagens para Testes de Resili√™ncia:",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        key="resilience_evidence_uploader"
    )
    if new_resilience_files:
        existing_fingerprints = {(e['name'], e['image'].size) for e in st.session_state.narrative_resilience_evidences if 'name' in e and 'image' in e}
        for uploaded_file in new_resilience_files:
            try:
                img_bytes = uploaded_file.getvalue()
                img = Image.open(BytesIO(img_bytes))
                file_fingerprint = (uploaded_file.name, img.size)
                if file_fingerprint not in existing_fingerprints:
                    st.session_state.narrative_resilience_evidences.append({
                        'image': img, 'test_name': '', 'description': '',
                        'report_image_filename': uploaded_file.name, 'raw_tool_output': '',
                        'id': str(uuid.uuid4()), 'name': uploaded_file.name
                    })
                    logging.info(f"Narrative Generator: Resilience evidence '{uploaded_file.name}' loaded.")
                else: st.info(f"Arquivo '{uploaded_file.name}' j√° carregado (Resilience).")
            except Exception as e: st.error(f"Erro ao carregar imagem para Resili√™ncia: {e}"); logging.error(f"Narrative Generator: Error loading resilience image: {e}.")

    resilience_evidences_to_remove = []
    for i, evidence in enumerate(st.session_state.narrative_resilience_evidences):
        st.markdown(f"**Resili√™ncia Evid√™ncia {i+1}:** `{evidence['name']}`")
        st.image(evidence['image'], use_container_width=True)
        st.session_state.narrative_resilience_evidences[i]['test_name'] = st.text_input(
            "Nome do Teste de Resili√™ncia:", value=evidence['test_name'],
            placeholder="Ex: Valida√ß√£o de Prote√ß√£o contra Clickjacking, Teste de CORS", key=f"resilience_test_name_{evidence['id']}"
        )
        st.session_state.narrative_resilience_evidences[i]['description'] = st.text_area(
            "Descri√ß√£o do Teste e Resultado Positivo (como a aplica√ß√£o demonstrou resili√™ncia):", value=evidence['description'],
            placeholder="Ex: 'Esta imagem mostra que o cabe√ßalho X-Frame-Options est√° configurado corretamente, impedindo o Clickjacking.'",
            key=f"resilience_desc_{evidence['id']}", height=100
        )
        st.session_state.narrative_resilience_evidences[i]['report_image_filename'] = st.text_input(
            "Nome do Arquivo da Imagem (Ex: `cors_ok.png`):", value=evidence['report_image_filename'],
            placeholder="nome-da-imagem.jpg", key=f"resilience_filename_{evidence['id']}"
        )
        st.session_state.narrative_resilience_evidences[i]['raw_tool_output'] = st.text_area(
            "Output Bruto da Ferramenta (Opcional para Resili√™ncia):", value=evidence['raw_tool_output'],
            placeholder="Cole o output do teste aqui (ex: cabe√ßalho de resposta HTTP).",
            key=f"resilience_raw_output_{evidence['id']}", height=100
        )
        if st.button(f"Remover Resili√™ncia Evid√™ncia {i+1}", key=f"remove_resilience_evidence_btn_{evidence['id']}"): resilience_evidences_to_remove.append(i)
    for index in sorted(resilience_evidences_to_remove, reverse=True): del st.session_state.narrative_resilience_evidences[index]; st.rerun()

    st.subheader("3. Gerar Narrativa")
    if st.button("Gerar Narrativa de Pentest", key="generate_narrative_button"):
        if not st.session_state.narrative_client_name or not st.session_state.narrative_app_name:
            st.error("Por favor, preencha o Nome do Cliente e o Nome da Aplica√ß√£o.")
            logging.warning("Narrative Generator: Gera√ß√£o abortada, dados do projeto incompletos.")
            return
        
        # Validar que pelo menos UMA evid√™ncia de qualquer tipo foi adicionada
        if not (st.session_state.narrative_recon_evidences or st.session_state.narrative_vuln_evidences or st.session_state.narrative_resilience_evidences):
            st.error("Por favor, adicione pelo menos uma evid√™ncia em qualquer uma das categorias.")
            logging.warning("Narrative Generator: Gera√ß√£o abortada, nenhuma evid√™ncia adicionada.")
            return

        # Valida√ß√£o mais detalhada de cada evid√™ncia antes de enviar ao LLM
        for i, evidence in enumerate(st.session_state.narrative_recon_evidences):
            if not evidence['description'] or not evidence['report_image_filename']:
                st.error(f"Reconhecimento Evid√™ncia {i+1}: Por favor, preencha a descri√ß√£o e o nome do arquivo da imagem.")
                logging.warning(f"Narrative Generator: Recon evidence {i+1} incomplete.")
                return
        for i, evidence in enumerate(st.session_state.narrative_vuln_evidences):
            if not evidence['vulnerability_name'] or not evidence['description'] or not evidence['report_image_filename']:
                st.error(f"Vulnerabilidade Evid√™ncia {i+1}: Por favor, preencha o nome, descri√ß√£o e o nome do arquivo da imagem.")
                logging.warning(f"Narrative Generator: Vuln evidence {i+1} incomplete.")
                return
        for i, evidence in enumerate(st.session_state.narrative_resilience_evidences):
            if not evidence['test_name'] or not evidence['description'] or not evidence['report_image_filename']:
                st.error(f"Resili√™ncia Evid√™ncia {i+1}: Por favor, preencha o nome do teste, descri√ß√£o e o nome do arquivo da imagem.")
                logging.warning(f"Narrative Generator: Resilience evidence {i+1} incomplete.")
                return

        with st.spinner("Gerando narrativa de pentest..."):
            logging.info(f"Narrative Generator: Iniciando gera√ß√£o para {st.session_state.narrative_client_name}/{st.session_state.narrative_app_name}.")

            # --- MODELO DE NARRATIVA BASE ---
            narrative_template = f"""
## Introdu√ß√£o

Foram conduzidos testes de seguran√ßa abrangentes com o objetivo de avaliar a robustez e a seguran√ßa da aplica√ß√£o **{st.session_state.narrative_app_name}** pertencente ao cliente **{st.session_state.narrative_client_name}**. Durante essa avalia√ß√£o, foram executadas diversas Provas de Conceito (PoCs) para identificar poss√≠veis vulnerabilidades, com base nos padr√µes da **OWASP Top 10**, **OWASP Mobile Top 10 (2024)** e nas melhores pr√°ticas da **Pentest Execution Standard (PTES)**.

Esses testes visaram localizar vulnerabilidades que poderiam comprometer a confidencialidade, integridade ou disponibilidade da aplica√ß√£o, permitindo uma an√°lise detalhada dos riscos potenciais e auxiliando na implementa√ß√£o de medidas de corre√ß√£o e mitiga√ß√£o.

## Achados de Reconhecimento e Mapeamento

## Vulnerabilidades Identificadas e Detalhamento

## Verifica√ß√µes de Seguran√ßa e Resili√™ncia

## Conclus√£o e Recomenda√ß√µes Finais

"""

            # Prepara as evid√™ncias CATEGORIZADAS para o LLM
            categorized_evidences_for_llm = {
                "recon_evidences": [],
                "vuln_evidences": [],
                "resilience_evidences": []
            }

            for i, ev in enumerate(st.session_state.narrative_recon_evidences):
                categorized_evidences_for_llm["recon_evidences"].append(
                    f"RECONHECIMENTO EVID√äNCIA {i+1}:\n"
                    f"Descri√ß√£o: {ev['description']}\n"
                    f"Nome do arquivo da imagem: {ev['report_image_filename']}\n"
                    f"Output Bruto da Ferramenta: {'(Nenhum fornecido)' if not ev['raw_tool_output'] else ev['raw_tool_output']}\n"
                    f"--------------------"
                )
            
            for i, ev in enumerate(st.session_state.narrative_vuln_evidences):
                categorized_evidences_for_llm["vuln_evidences"].append(
                    f"VULNERABILIDADE EVID√äNCIA {i+1}:\n"
                    f"Nome da Vulnerabilidade: {ev['vulnerability_name']}\n"
                    f"Severidade: {ev['severity']}\n"
                    f"Descri√ß√£o do Problema: {ev['description']}\n"
                    f"Nome do arquivo da imagem: {ev['report_image_filename']}\n"
                    f"Output Bruto da Ferramenta: {'(Nenhum fornecido)' if not ev['raw_tool_output'] else ev['raw_tool_output']}\n"
                    f"--------------------"
                )
            
            for i, ev in enumerate(st.session_state.narrative_resilience_evidences):
                categorized_evidences_for_llm["resilience_evidences"].append(
                    f"RESILI√äNCIA EVID√äNCIA {i+1}:\n"
                    f"Nome do Teste: {ev['test_name']}\n"
                    f"Descri√ß√£o do Teste e Resultado Positivo: {ev['description']}\n"
                    f"Nome do arquivo da imagem: {ev['report_image_filename']}\n"
                    f"Output Bruto da Ferramenta: {'(Nenhum fornecido)' if not ev['raw_tool_output'] else ev['raw_tool_output']}\n"
                    f"--------------------"
                )

            # --- IN√çCIO DA MELHORIA: T√âCNICA FEW-SHOT PROMPTING ---
            exemplo_de_qualidade = """
**EXEMPLO DE REFER√äNCIA DE ALTA QUALIDADE (N√ÉO INCLUA ESTE EXEMPLO NA SA√çDA FINAL):**
'### Cross-Site Scripting (XSS) Refletido
Durante a fase de explora√ß√£o, foi identificado que o par√¢metro 'query' na URL de busca n√£o sanitizava adequadamente a entrada do usu√°rio. Ao injetar o payload `<script>alert('XSS by HuntIA')</script>`, foi poss√≠vel executar c√≥digo JavaScript arbitr√°rio no contexto do navegador da v√≠tima, como evidenciado na imagem `xss_poc.png`. Esta falha √© classificada como **M√©dia** e pode levar ao roubo de cookies de sess√£o, phishing e desfigura√ß√£o da p√°gina.
**Recomenda√ß√£o:** A mitiga√ß√£o requer a implementa√ß√£o de Output Encoding em todas as sa√≠das de dados que refletem a entrada do usu√°rio. Especificamente, caracteres como `<`, `>`, `"` devem ser convertidos para suas entidades HTML (`&lt;`, `&gt;`, `&quot;`).'
"""
            # --- FIM DA MELHORIA ---

            global_context_prompt = get_global_context_prompt()

            prompt_instructions = (
                f"Voc√™ √© um especialista em seguran√ßa da informa√ß√£o e pentest, com vasta experi√™ncia na reda√ß√£o de relat√≥rios t√©cnicos de pentest."
                f"{global_context_prompt}"
                f"\n\n{exemplo_de_qualidade}" # Adicionando o exemplo de alta qualidade
                f"\n\nUse o exemplo acima como um guia para o n√≠vel de detalhe, tom t√©cnico e formato que voc√™ deve seguir ao descrever cada vulnerabilidade."
                f"\n\nSua tarefa √© gerar uma narrativa de relat√≥rio de pentest abrangente e profissional para a aplica√ß√£o '{st.session_state.narrative_app_name}' do cliente '{st.session_state.narrative_client_name}'. "
                f"O tipo principal de pentest √© '{st.session_state.narrative_pentest_type}'. Ajuste sua linguagem, o foco das vulnerabilidades e prioridade de achados a isso."
                f"\n\nVoc√™ receber√° um modelo de narrativa com se√ß√µes principais e **evid√™ncias pr√©-categorizadas** (Reconhecimento, Vulnerabilidades, Resili√™ncia). Seu objetivo √©:"
                f"\n1.¬† **Preencher e Expandir as se√ß√µes principais do modelo** com base nas evid√™ncias fornecidas em cada categoria. Mantenha os t√≠tulos das se√ß√µes principais (`## Introdu√ß√£o`, `## Achados de Reconhecimento e Mapeamento`, etc.) exatamente como est√£o."
                f"\n2.¬† Para cada **evid√™ncia de 'RECONHECIMENTO E MAPEAMENTO'**: Use a 'Descri√ß√£o' e o 'Output Bruto da Ferramenta' (se fornecido) para elaborar um par√°grafo detalhado sobre a atividade de reconhecimento e seus achados. Insira a refer√™ncia da imagem no formato `![](/images/name/[nome_do_arquivo_da_imagem]){{width=\"auto\"}}` logo abaixo do par√°grafo que a descreve."
                f"\n3.¬† Para cada **evid√™ncia de 'VULNERABILIDADE'**: Crie um subt√≠tulo `### [Nome da Vulnerabilidade]`. Descreva a vulnerabilidade em termos gerais. Utilize a 'Descri√ß√£o do Problema' e o 'Output Bruto da Ferramenta' (se fornecido) para detalhar como a falha se manifestou/foi explorada e seu impacto. Forne√ßa o impacto t√©cnico/de neg√≥cio e uma recomenda√ß√£o t√©cnica clara para mitiga√ß√£o. Insira a refer√™ncia da imagem no formato `![](/images/name/[nome_do_arquivo_da_imagem]){{width=\"auto\"}}` logo abaixo do par√°grafo. Classifique a severidade."
                f"\n4.¬† Para cada **evid√™ncia de 'RESILI√äNCIA'**: Crie um subt√≠tulo `### [Nome do Teste]`. Descreva o teste realizado e seu objetivo. Utilize a 'Descri√ß√£o do Teste e Resultado Positivo' e o 'Output Bruto da Ferramenta' (se fornecido) para detalhar como a aplica√ß√£o demonstrou resili√™ncia, explicando os controles que impediram a explora√ß√£o. Destaque as boas pr√°ticas. Insira a refer√™ncia da imagem no formato `![](/images/name/[nome_do_arquivo_da_imagem]){{width=\"auto\"}}` logo abaixo do par√°grafo."
                f"\n5.¬† **Organize os achados/testes nas se√ß√µes correspondentes**. Priorize vulnerabilidades de maior severidade primeiro dentro de suas se√ß√µes."
                f"\n6.¬† A se√ß√£o **'Conclus√£o e Recomenda√ß√µes Finais' deve ser a √öLTIMA se√ß√£o e aparecer APENAS UMA VEZ no documento.** Resuma o estado geral de seguran√ßa da aplica√ß√£o, destacando pontos fortes (resili√™ncia) e √°reas que exigem aten√ß√£o (vulnerabilidades) e recomenda√ß√µes cont√≠nuas, baseadas em *todos* os achados."
                f"\n7.¬† **Mantenha um tom t√©cnico, claro, conciso e profissional em toda a narrativa.**"
                f"\n8.¬† **N√£o inclua quaisquer notas adicionais, cabe√ßalhos de LLM, ou formata√ß√µes extras que n√£o sejam a narrativa final do relat√≥rio.**"
                f"\n\n--- Modelo de Se√ß√µes do Relat√≥rio ---\n"
                + f"{narrative_template}" + # Injetando o template predefinido aqui
                f"\n--- Evid√™ncias de Reconhecimento (para preencher o modelo) ---\n" +
                "\n".join(categorized_evidences_for_llm["recon_evidences"]) +
                f"\n--- Evid√™ncias de Vulnerabilidades (para preencher o modelo) ---\n" +
                "\n".join(categorized_evidences_for_llm["vuln_evidences"]) +
                f"\n--- Evid√™ncias de Resili√™ncia (para preencher o modelo) ---\n" +
                "\n".join(categorized_evidences_for_llm["resilience_evidences"])
            )

            # A l√≥gica de gera√ß√£o e extra√ß√£o da conclus√£o permanece a mesma
            generated_text_raw = obter_resposta_llm(llm_model_text, [prompt_instructions])

            if generated_text_raw:
                st.session_state.generated_narrative_output = generated_text_raw.strip()
                
                conclusion_match = re.search(r"## Conclus√£o e Recomenda√ß√µes Finais\n(.*?)(?=(## |\Z))", st.session_state.generated_narrative_output, re.DOTALL)
                if conclusion_match:
                    st.session_state.narrative_summary_output = conclusion_match.group(1).strip()
                else:
                    st.session_state.narrative_summary_output = "Conclus√£o n√£o detectada ou formatada incorretamente na narrativa. Por favor, verifique a narrativa completa."
                
                st.success("Narrativa de pentest gerada com sucesso!")
                logging.info("Pentest Narrative Generator: Narrativa gerada com sucesso.")
            else:
                st.session_state.generated_narrative_output = "N√£o foi poss√≠vel gerar a narrativa. Tente novamente ou ajuste as entradas."
                st.session_state.narrative_summary_output = ""
                logging.error("Pentest Narrative Generator: Falha na gera√ß√£o da narrativa pelo LLM.")
    
    if st.session_state.generated_narrative_output:
        st.subheader("Narrativa de Pentest Gerada:")
        st.markdown(st.session_state.generated_narrative_output)

        if st.session_state.narrative_summary_output:
            st.markdown("---")
            st.subheader("Conclus√£o da An√°lise (Extra√≠da):")
            st.markdown(st.session_state.narrative_summary_output)

        col_download_md, col_download_txt = st.columns(2)
        with col_download_md:
            st.download_button(
                label="Download Narrativa (.md)",
                data=st.session_state.generated_narrative_output.encode('utf-8'),
                file_name=f"narrativa_{st.session_state.narrative_client_name.replace(' ','_')}_{st.session_state.narrative_app_name.replace(' ','_')}.md",
                mime="text/markdown",
                help="Baixe a narrativa em formato Markdown, ideal para seu relat√≥rio."
            )
        with col_download_txt:
            st.download_button(
                label="Download Narrativa (.txt)",
                data=st.session_state.generated_narrative_output.encode('utf-8'),
                file_name=f"narrativa_{st.session_state.narrative_client_name.replace(' ','_')}_{st.session_state.narrative_app_name.replace(' ','_')}.txt",
                mime="text/plain",
                help="Baixe a narrativa em formato de texto simples."
            )
        
        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="narrative_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Pentest Narrative Generator: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="narrative_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Pentest Narrative Generator: Precisa de Melhoria.")

def parse_vulnerability_summary(text_response):
    """Extrai o resumo de vulnerabilidades da resposta do LLM."""
    summary = {
        "Total": 0,
        "Cr√≠ticos": 0,
        "Altos": 0,
        "M√©dios": 0,
        "Baixos": 0
    }

    # Procura pela linha de resumo
    summary_line = None
    lines = text_response.split('\n')
    for line in lines:
        if line.strip().startswith("Total de Achados"):
            summary_line = line
            break

    if not summary_line:
        logging.warning("Mobile Static Analyzer: Resumo de vulnerabilidades n√£o encontrado na resposta do LLM.")
        return summary

    # Extrair n√∫meros com regex
    matches = re.findall(r'(\d+)', summary_line)
    if len(matches) >= 5:
        summary["Total"] = int(matches[0])
        summary["Cr√≠ticos"] = int(matches[1])
        summary["Altos"] = int(matches[2])
        summary["M√©dios"] = int(matches[3])
        summary["Baixos"] = int(matches[4])

    return summary


def parse_vulnerability_details(text_response):
    """Extrai os detalhes das vulnerabilidades a partir da resposta do LLM."""
    details = []
    blocks = re.split(r'\n\s*###\s*', text_response)[1:]  # Ignora o bloco antes do primeiro ###

    for block in blocks:
        lines = block.strip().split('\n')
        if not lines:
            continue

        name = re.sub(r'\*\*Nome da Vulnerabilidade:\*\*', '', lines[0]).strip()
        category = re.sub(r'\*\*Categoria OWASP Mobile.*:\*\*', '', lines[1]).strip()
        severity = re.sub(r'\*\*Severidade/Risco:\*\*', '', lines[2]).strip()
        location = re.sub(r'\*\*Localiza√ß√£o na Especifica√ß√£o:\*\*', '', lines[3]).strip()
        detail = re.sub(r'\*\*Detalhes:\*\*', '', lines[4]).strip()

        if name and category and severity and location and detail:
            details.append({
                "name": name,
                "category": category,
                "severity": severity,
                "location": location,
                "details": detail
            })

    return details


def mobile_app_static_analysis_page(llm_model_vision, llm_model_text):
    st.header("Mobile Static Analyzer üì±")
    st.markdown("""
    Realize an√°lise est√°tica de seguran√ßa em aplicativos Android.  
    Fa√ßa upload de um arquivo `.zip` contendo o APK descompilado (sa√≠da de ferramentas como `apktool -d` ou `jadx -d`),  
    ou cole trechos de c√≥digo ou o `AndroidManifest.xml` diretamente.  

    O HuntIA ir√° analisar o conte√∫do para identificar vulnerabilidades com base na **OWASP Mobile Top 10** e fornecer recomenda√ß√µes.

    ‚ö†Ô∏è **AVISO:** Esta √© uma an√°lise est√°tica de *primeira linha* e n√£o substitui uma revis√£o de c√≥digo manual completa.
    """)
    logging.info("P√°gina Mobile Static Analyzer acessada.")

    # Inicializar vari√°veis de sess√£o
    if 'mobile_analysis_type' not in st.session_state:
        st.session_state.mobile_analysis_type = "Upload ZIP (APK Descompilado)"
    if 'uploaded_decompiled_zip' not in st.session_state:
        st.session_state.uploaded_decompiled_zip = None
    if 'manifest_content' not in st.session_state:
        st.session_state.manifest_content = ""
    if 'code_snippet_content' not in st.session_state:
        st.session_state.code_snippet_content = ""
    if 'mobile_analysis_result' not in st.session_state:
        st.session_state.mobile_analysis_result = ""
    if 'mobile_analysis_summary' not in st.session_state:
        st.session_state.mobile_analysis_summary = None

    def reset_mobile_analysis():
        st.session_state.mobile_analysis_type = "Upload ZIP (APK Descompilado)"
        st.session_state.uploaded_decompiled_zip = None
        st.session_state.manifest_content = ""
        st.session_state.code_snippet_content = ""
        st.session_state.mobile_analysis_result = ""
        st.session_state.mobile_analysis_summary = None
        logging.info("Mobile Static Analyzer: Reset de campos.")
        st.rerun()

    if st.button("Limpar An√°lise Mobile", key="reset_mobile_analysis_button"):
        reset_mobile_analysis()

    # Tipo de an√°lise
    analysis_type_options = [
        "Upload ZIP (APK Descompilado)",
        "Colar AndroidManifest.xml",
        "Colar Trecho de C√≥digo (Java/Smali/Kotlin)"
    ]
    st.session_state.mobile_analysis_type = st.radio(
        "Como deseja fornecer o conte√∫do para an√°lise?",
        options=analysis_type_options,
        key="mobile_analysis_type_radio"
    )

    analyzed_content = ""
    analysis_context = ""

    # Upload ZIP
    if st.session_state.mobile_analysis_type == "Upload ZIP (APK Descompilado)":
        uploaded_zip_file = st.file_uploader("Selecione o arquivo .zip do APK descompilado:", type=["zip"], key="mobile_zip_uploader")
        if uploaded_zip_file:
            st.session_state.uploaded_decompiled_zip = uploaded_zip_file
            with tempfile.TemporaryDirectory() as tmpdir:
                try:
                    with zipfile.ZipFile(uploaded_zip_file, 'r') as zip_ref:
                        zip_ref.extractall(tmpdir)

                    manifest_path = os.path.join(tmpdir, "AndroidManifest.xml")
                    if os.path.exists(manifest_path):
                        with open(manifest_path, 'r', encoding='utf-8', errors='ignore') as f:
                            st.session_state.manifest_content = f.read()
                        analysis_context += f"Conte√∫do do AndroidManifest.xml:```xml{st.session_state.manifest_content}```"

                    code_files_content = []
                    max_code_size = 200 * 1024  # 200KB
                    current_code_size = 0
                    code_file_count = 0

                    for root, _, files in os.walk(tmpdir):
                        for file in files:
                            if file.endswith(".java") or file.endswith(".smali") or file.endswith(".kt"):
                                file_path = os.path.join(root, file)
                                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                    content = f.read()
                                    if current_code_size + len(content) > max_code_size:
                                        logging.info("Mobile Static Analyzer: Limite de tamanho de c√≥digo atingido.")
                                        break
                                    code_files_content.append(f"- C√≥digo de: {file}\n{content}")
                                    current_code_size += len(content)
                                    code_file_count += 1

                        if current_code_size >= max_code_size:
                            break

                    if code_files_content:
                        st.session_state.code_snippet_content = "\n\n".join(code_files_content)
                        analysis_context += f"Trechos de C√≥digo (total {code_file_count} arquivos, {current_code_size / 1024:.2f} KB):```{st.session_state.code_snippet_content}```"
                        logging.info(f"Mobile Static Analyzer: {code_file_count} arquivos de c√≥digo processados.")
                    else:
                        st.info("Nenhum arquivo de c√≥digo relevante encontrado no ZIP.")
                        logging.info("Mobile Static Analyzer: Nenhum arquivo de c√≥digo encontrado no ZIP.")

                except Exception as e:
                    st.error(f"Erro ao processar o arquivo ZIP: {e}")
                    logging.exception(f"Mobile Static Analyzer: Erro ao processar ZIP: {e}.")
                    st.session_state.uploaded_decompiled_zip = None

            analyzed_content = analysis_context.replace('{', '{{').replace('}', '}}')

    elif st.session_state.mobile_analysis_type == "Colar AndroidManifest.xml":
        st.session_state.manifest_content = st.text_area(
            "Cole o conte√∫do do AndroidManifest.xml aqui:",
            value=st.session_state.manifest_content,
            placeholder="<manifest ...><uses-permission android:name=\"android.permission.INTERNET\"/>...</manifest>",
            height=400,
            key="manifest_input_area"
        )
        escaped_manifest = st.session_state.manifest_content.replace('{', '{{').replace('}', '}}')
        analyzed_content = f"Conte√∫do do AndroidManifest.xml:```xml{escaped_manifest}```"
        logging.info("Mobile Static Analyzer: Conte√∫do do AndroidManifest.xml lido.")

    elif st.session_state.mobile_analysis_type == "Colar Trecho de C√≥digo (Java/Smali/Kotlin)":
        st.session_state.code_snippet_content = st.text_area(
            "Cole trechos de c√≥digo Java/Smali/Kotlin aqui (mantenha relevante e conciso):",
            value=st.session_state.code_snippet_content,
            placeholder="Ex: public class SecretHolder {\nprivate static final String API_KEY = \"sk-123xyz\";\n}",
            height=400,
            key="code_snippet_input_area"
        )
        escaped_code = st.session_state.code_snippet_content.replace('{', '{{').replace('}', '}}')
        analyzed_content = f"Trecho de C√≥digo para An√°lise:```java{escaped_code}```"
        logging.info("Mobile Static Analyzer: Trecho de c√≥digo colado pelo usu√°rio.")

    if st.button("Analisar Aplicativo Mobile", key="analyze_mobile_app_button"):
        if not analyzed_content.strip():
            st.error("Por favor, forne√ßa o conte√∫do para an√°lise.")
            logging.warning("Mobile Static Analyzer: An√°lise abortada, conte√∫do vazio.")
            return

        with st.spinner("Analisando aplicativo mobile estaticamente com LLM..."):
            logging.info("Mobile Static Analyzer: Iniciando an√°lise est√°tica.")

            global_context_prompt = get_global_context_prompt()

            mobile_analysis_prompt = (
                f"Voc√™ √© um especialista em seguran√ßa de aplicativos m√≥veis e pentest, com profundo conhecimento na **OWASP Mobile Top 10 (2024)**.\n"
                f"{global_context_prompt}\n\n"
                f"Sua tarefa √© analisar o conte√∫do descompilado de um aplicativo Android (APK) fornecido a seguir. Identifique **TODAS as potenciais vulnerabilidades de seguran√ßa** com base nas categorias da OWASP Mobile Top 10, bem como outras falhas comuns em aplicativos mobile.\n\n"
                f"**RESUMO:** Forne√ßa um resumo quantitativo na PRIMEIRA LINHA da sua resposta, no formato exato: `Total de Achados: X | Cr√≠ticos: Y | Altos: Z | M√©dios: W | Baixos: V` (substitua X,Y,Z,W,V pelos n√∫meros correspondentes). Se n√£o houver achados, use 0.\n\n"
                f"Para cada **achado de seguran√ßa** identificado, apresente de forma concisa e pr√°tica, utilizando Markdown para formata√ß√£o:\n\n"
                f"### [Nome da Vulnerabilidade] (Ex: Chave de API Hardcoded, Comunica√ß√£o N√£o Criptografada)\n"
                f"**Categoria OWASP Mobile (2024):** [Ex: M1: Improper Platform Usage]\n"
                f"**Severidade/Risco:** [Alta/M√©dia/Baixa - explique o impacto espec√≠fico para esta vulnerabilidade]\n"
                f"**Localiza√ß√£o na Especifica√ß√£o:** Indique onde foi encontrada a vulnerabilidade (ex: `AndroidManifest.xml`, `MainActivity.java`).\n"
                f"**Detalhes:** Explique o problema t√©cnico e como ele ocorre.\n\n"
                f"**Conte√∫do para An√°lise:**\n{analyzed_content}\n\n"
                f"Se n√£o encontrar vulnerabilidades √≥bvias, indique isso claramente."
            )

            analysis_result_raw = obter_resposta_llm(llm_model_text, [mobile_analysis_prompt])
            if analysis_result_raw:
                st.session_state.mobile_analysis_result = analysis_result_raw
                st.session_state.mobile_analysis_summary = parse_vulnerability_summary(analysis_result_raw)
                logging.info("Mobile Static Analyzer: An√°lise conclu√≠da com sucesso.")
            else:
                st.session_state.mobile_analysis_result = "N√£o foi poss√≠vel realizar a an√°lise est√°tica mobile. Tente refinar o conte√∫do ou ajustar o APK descompilado."
                st.session_state.mobile_analysis_summary = None
                logging.error("Mobile Static Analyzer: Falha na an√°lise pelo LLM.")

    # Exibir resultados
    if st.session_state.mobile_analysis_result:
        st.subheader("Resultados da An√°lise Est√°tica Mobile")

        if st.session_state.mobile_analysis_summary:
            cols = st.columns(5)
            cols[0].metric("Total", st.session_state.mobile_analysis_summary.get("Total", 0))
            cols[1].metric("Cr√≠ticos", st.session_state.mobile_analysis_summary.get("Cr√≠ticos", 0))
            cols[2].metric("Altos", st.session_state.mobile_analysis_summary.get("Altos", 0))
            cols[3].metric("M√©dios", st.session_state.mobile_analysis_summary.get("M√©dios", 0))
            cols[4].metric("Baixos", st.session_state.mobile_analysis_summary.get("Baixos", 0))

        vulnerability_details = parse_vulnerability_details(st.session_state.mobile_analysis_result)

        if vulnerability_details:
            for vuln in vulnerability_details:
                st.markdown(f"### {vuln['name']}")
                st.markdown(f"**Categoria OWASP Mobile (2024):** {vuln['category']}")
                st.markdown(f"**Severidade/Risco:** {vuln['severity']}")
                st.markdown(f"**Localiza√ß√£o na Especifica√ß√£o:** {vuln['location']}")
                st.markdown(f"**Detalhes:** {vuln['details']}")
                st.markdown("---")
        else:
            st.info("Nenhuma vulnerabilidade detalhada encontrada na resposta do LLM.")

        # Feedback Buttons
        cols_feedback = st.columns(2)
        if cols_feedback[0].button("üëç √ötil", key="mobile_analysis_feedback_good"):
            st.toast("Obrigado pelo seu feedback! Isso nos ajuda a melhorar.", icon="üòä")
            logging.info("Feedback Mobile Static Analyzer: √ötil.")
        if cols_feedback[1].button("üëé Precisa de Melhoria", key="mobile_analysis_feedback_bad"):
            st.toast("Obrigado pelo seu feedback. Continuaremos trabalhando para aprimorar.", icon="üòî")
            logging.info("Feedback Mobile Static Analyzer: Precisa de Melhoria.")


# --- Main Application Logic ---
def main():
    llm_model_vision, llm_model_text = get_gemini_models_cached()

    if not llm_model_vision or not llm_model_text:
        st.warning("Modelos LLM n√£o carregados. Algumas funcionalidades podem n√£o estar dispon√≠veis.")
        return

    # Inicializa todos os estados globais na primeira execu√ß√£o para evitar erros
    if 'global_profile' not in st.session_state: st.session_state.global_profile = "Nenhum"
    if 'global_scenario' not in st.session_state: st.session_state.global_scenario = "Nenhum"
    if 'projeto_ativo_id' not in st.session_state: st.session_state.projeto_ativo_id = None
    if 'projeto_ativo_nome' not in st.session_state: st.session_state.projeto_ativo_nome = None
    if 'modo_rascunho' not in st.session_state: st.session_state.modo_rascunho = True # Inicia em modo rascunho por padr√£o
    
    with st.sidebar:
        # Adiciona um status r√°pido e limpo na sidebar para o usu√°rio sempre saber como est√° operando
        st.markdown("##### Modo de Opera√ß√£o")
        if st.session_state.get('modo_rascunho', True):
            st.info("Modo Rascunho ‚úèÔ∏è")
        elif st.session_state.get('projeto_ativo_nome'):
            st.success(f"Projeto: {st.session_state.projeto_ativo_nome}")
        else:
            # Este aviso incentiva o usu√°rio a ir para as configura√ß√µes
            st.warning("Nenhum projeto selecionado.")
        st.markdown("---")
            
        selected = option_menu(
            menu_title="Navega√ß√£o Principal",
            options=[
                "In√≠cio",
                "Configura√ß√µes", # <-- NOVA P√ÅGINA
                "Correlation Dashboard",
                "OWASP Vulnerability Details",
                "Deep HTTP Insight",
                "OWASP Image Analyzer",
                "PoC Generator (HTML)",
                "OpenAPI Analyzer",
                "Static Code Analyzer",
                "Tactical Command Orchestrator",
                "Pentest Playbook Generator",
                "Intelligent Pentest Validator",
                "Pentest Narrative Generator",
                "Mobile Static Analyzer"
            ],
            icons=[
                "house", "gear-fill", # <-- NOVO √çCONE
                "diagram-3", "bug", "globe", "image", "file-earmark-code",
                "file-earmark-richtext", "code-slash", "terminal",
                "book", "check-square", "file-earmark-text", "phone"
            ],
            menu_icon="tools",
            default_index=0,
             styles={
                "container": {"padding": "0!important", "background-color": "#262730"},
                "icon": {"color": "#E50000", "font-size": "20px"},
                "nav-link": {"font-size": "16px", "text-align": "left", "margin":"0px", "--hover-color": "#4a4a5c"},
                "nav-link-selected": {"background-color": "#E50000"},
            }
        )
    
        st.sidebar.markdown("---")
        st.sidebar.download_button(
            label="Download Log do Aplicativo",
            data=get_log_file_content(),
            file_name="huntia_application.log",
            mime="text/plain"
        )

    # L√≥gica de roteamento para cada p√°gina da aplica√ß√£o
    if selected == "In√≠cio":
        home_page()
    elif selected == "Configura√ß√µes":
        settings_page() # <-- ROTA PARA A NOVA P√ÅGINA
    elif selected == "Correlation Dashboard":
        correlation_dashboard_page(llm_model_text)
    elif selected == "OWASP Vulnerability Details":
        owasp_text_analysis_page(llm_model_vision, llm_model_text)
    elif selected == "Deep HTTP Insight":
        http_request_analysis_page(llm_model_vision, llm_model_text)
    elif selected == "OWASP Image Analyzer":
        owasp_scout_visual_page(llm_model_vision, llm_model_text)
    elif selected == "PoC Generator (HTML)":
        poc_generator_html_page(llm_model_vision, llm_model_text)
    elif selected == "OpenAPI Analyzer":
        swagger_openapi_analyzer_page(llm_model_vision, llm_model_text)
    elif selected == "Static Code Analyzer":
        static_code_analyzer_page(llm_model_vision, llm_model_text)
    elif selected == "Tactical Command Orchestrator":
        tactical_command_orchestrator_page(llm_model_text)
    elif selected == "Pentest Playbook Generator":
        pentest_playbook_generator_page(llm_model_text)
    elif selected == "Intelligent Pentest Validator":
        intelligent_pentest_validator_page(llm_model_vision, llm_model_text)
    elif selected == "Pentest Narrative Generator":
        pentest_narrative_generator_page(llm_model_vision, llm_model_text)
    elif selected == "Mobile Static Analyzer":
        mobile_app_static_analysis_page(llm_model_vision, llm_model_text)

if __name__ == "__main__":
    main()